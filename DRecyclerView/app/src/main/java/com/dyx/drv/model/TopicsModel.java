package com.dyx.drv.model;

import java.util.List;

/**
 * Created by dayongxin on 2016/9/18.
 */
public class TopicsModel {

    /**
     * success : true
     * data : [{"id":"575d28576121c03a6e955f19","author_id":"50725bc001d0b80148f48097","tab":"job","content":"<div class=\"markdown-text\"><p>杭州大搜车，诚聘 Node.js 服务端开发！<\/p>\n<p>加分项：<\/p>\n<ul>\n<li>优秀的推动能力；<\/li>\n<li>真正的参与开源项目；<\/li>\n<li>厚实的服务端开发经验；<\/li>\n<li><strong>不<\/strong>是\u201c全栈开发\u201d；<\/li>\n<li>有其他后台语言的开发和架构经验<\/li>\n<\/ul>\n<p>下面是详细的招聘说明<\/p>\n<h2>关于公司<\/h2>\n<p>大搜车位于杭州市余杭区五常大道 175 号，独立 2 栋连体办公楼，办公环境一级棒，一楼有很大的健身区 / 台球室 / 瑜伽房，还有大面积的室内停车位。<\/p>\n<p>公司创立于 2013 年，在二手车行业摸打滚爬 3 余载，融资已经 D 轮，投资方碉堡不过还不能透露。公司业务一路从 B2C，到 B2B，到后来融合大小商家的管理系统，质保金融系统，一直走在同行业的前列，网站 App 已经被抄了 N 次，不过并没有卵用，看着一个个追随者在后面你死我活的，我司笑而不语。<\/p>\n<h2>关于团队<\/h2>\n<p>大搜车前端研发部开始于 2014 年，成立近两年来，沉淀了很多技术方面的经验，公司主技术栈：VueJS，AngularJS，ReactJS，Webpack + 传统选型等，开始我们的选型其实很保守，也制定了很多变态的规范，因为初期很多东西很难把握，规范和简单可以让团队的代码维护性保持健康可控的成长。后来团队同学慢慢成长起来后，前端圈的一些技术也越来越成熟，我们对一些常用技术栈做了深入尝试，并且总结每个解决方案的问题和优势，对其中一些方案标准化，对各自使用的场景也基本有自己的理解，现在团队技术栈比较开，鼓励大家尝试新东西，并且把我代码可维护性。<\/p>\n<p>团队同时承接一块重要的服务端业务，使用 Nodejs 开发，团队的 NodeJS 开发均是纯服务端出身的大拿，我觉得这一点对于 Node.js 服务端开发还是很重要的，毕竟 Node.js 只是一个工具。我们的业务非常复杂，所以对于开发同学的挑战也很大，包括业务上的还有系统保障上，都做了很多事情，现在也还在成长中。不过在公司内，大家非常尊重这种异构的文化，每一种语言都有自己的特长，互相融合互相竞争能更好的营造技术氛围。<\/p>\n<p>我们有自己的node服务化开发框架，node日志&amp;报警系统，node性能监控系统，内部npm，Node底层SDK化，开发文档接口定义系统，自己的ORM库，公共队列系统，自动化运维体系，执行严格的gitflow&amp;&amp;eslint规范，完善的单测方案。还有更多好玩的需要你的加入。<\/p>\n<h2>福利<\/h2>\n<p>全员 Retina Macbook Pro，免费高档健康晚餐，每月团队活动基金，每周的组内技术分享，全员持股，每年普发一次期权，然后根据贡献发一次期权，每年涨薪！健身房台球室随便玩！还能免费洗车！<\/p>\n<h2>招聘<\/h2>\n<p>目前因为 D 轮马上就要到账了，业务急剧增加，同时我们还要做很多应对业务增长的底层优化和周边保障，所以急需前端开发工程师和 Node.js 开发工程师加入我们团队。<\/p>\n<h3>具体要求<\/h3>\n<h4>前端开发<\/h4>\n<ul>\n<li>熟悉 Vue / Angular / React 至少一个库，有实际开发经验。<\/li>\n<li>对自己做过的项目，用过的方案有深入思考，最好简历里有所体现。<\/li>\n<li>对技术有热情，乐于接触新事物，做事情态度端正。<\/li>\n<\/ul>\n<h4>Node.js 服务端<\/h4>\n<ul>\n<li>熟悉 Express / Koa 等常用框架，对 MVC 有一定了解，或者有自己的一套应用开发理念。<\/li>\n<li>熟悉数据库操作，熟悉缓存应用。<\/li>\n<li>熟悉常见的应用性能优化，监控，分析方法。<\/li>\n<li>熟悉常用的 NPM 库。<\/li>\n<li>熟悉标准 Git Flow 开发流程。<\/li>\n<li>有单元测试 &amp; 集成测试自动化经验。<\/li>\n<\/ul>\n<blockquote>\n<p>加分项： 有或者参与 Github 开源项目。 有博客。 是漂亮妹子。<\/p>\n<\/blockquote>\n<h2>联系方式<\/h2>\n<p>简历直接发送至邮箱： <a href=\"mailto:sunxinyu@souche.com\">sunxinyu@souche.com<\/a> 。如果您符合要求，会第一时间约见。<\/p>\n<p>如果还有其他疑问，可以加我微信（微信号：mier963）<\/p>\n<\/div>","title":"杭州大搜车Node服务端团队需要您的加入！","last_reply_at":"2016-09-14T02:50:09.562Z","good":true,"top":false,"reply_count":28,"visit_count":3674,"create_at":"2016-06-12T09:16:07.245Z","author":{"loginname":"xinyu198736","avatar_url":"//gravatar.com/avatar/d00d8e3461257418a62b1cb7abeea85a?size=48"}},{"id":"5709959abc564eaf3c6a48c8","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>Koa 2入门<\/h1>\n<p><img src=\"//dn-cnode.qbox.me/FqcnDVOK0DDnCKZ0M5i_F9gAiSNR\" alt=\"Screen-Shot-2016-04-01-at-1.52.56-PM.jpg\"><\/p>\n<p>koa2已发布了一段时间，可以考虑入手，参见<a href=\"https://cnodejs.org/topic/56fdf66ec5f5b4a959e91771\">Node.js最新Web技术栈（2016年4月）<\/a><\/p>\n<p>本文主要是<a href=\"https://github.com/koajs/koa/blob/v2.x/Readme.md\">koa 2的文档<\/a>解读和<a href=\"https://github.com/17koa/runkoa\">runkoa<\/a>介绍，让大家对koa 2有一个更简单直接的理解<\/p>\n<h2>依赖Node.js 4.0+<\/h2>\n<p>Koa requires node v4.0.0 or higher for (partial) ES2015 support.<\/p>\n<p>部分特性需要ES2015,大家可以自己比对一下es6在node不同版本里的支持特性<\/p>\n<p><a href=\"http://kangax.github.io/compat-table/es6/\">http://kangax.github.io/compat-table/es6/<\/a><\/p>\n<h2>hello world<\/h2>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst app = new Koa();\n\n&#x2F;&#x2F; 此处开始堆叠各种中间件\n&#x2F;&#x2F;...\n\napp.use(ctx =&gt; {\n  ctx.body = &#x27;Hello Koa&#x27;;\n});\n\napp.listen(3000);\n<\/code><\/pre><p>注意注释部分，此处开始堆叠各种中间件<\/p>\n<h2>中间件：Middleware<\/h2>\n<p>Koa 是一个 middleware framework, 它提供了 3 种不同类型的中间件写法<\/p>\n<ul>\n<li>common function<\/li>\n<li>async function（新增）<\/li>\n<li>generatorFunction<\/li>\n<\/ul>\n<p>中间件和express的中间件类似，是有顺序的，注意，大部分人都坑死在顺序上<\/p>\n<p>下面以写一个logger中间件为例，一一阐明<\/p>\n<h3>最常见的写法<\/h3>\n<p>node sdk就支持的，就是最常见的<\/p>\n<p>app.js<\/p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst app = new Koa();\n\napp.use((ctx, next) =&gt; {\n  const start = new Date();\n  return next().then(() =&gt; {\n    const ms = new Date() - start;\n    console.log(&#96;${ctx.method} ${ctx.url} - ${ms}ms&#96;);\n  });\n});\n\n\n&#x2F;&#x2F; response\napp.use(ctx =&gt; {\n  ctx.body = &#x27;Hello Koa in app.js&#x27;;\n});\n\napp.listen(3000);\n<\/code><\/pre><h3>async/await 函数 (Babel required)<\/h3>\n<p>async/await是异步流程控制更好的解决方案，很多潮人都已经玩起来了，目前node sdk不支持，所以需要babel来转换一下<\/p>\n<p>app-async.js<\/p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst app = new Koa();\n\napp.use(async (ctx, next) =&gt; {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  console.log(&#96;${ctx.method} ${ctx.url} - ${ms}ms&#96;);\n});\n\n&#x2F;&#x2F; response\napp.use(ctx =&gt; {\n  ctx.body = &#x27;Hello Koa in app-async.js&#x27;;\n});\n\napp.listen(3000);\n<\/code><\/pre><h3>Generator函数<\/h3>\n<p>Generator是node 4（严格是0.12）开始支持的es6特性里的非常重要的一个，用generator和promise实现流程控制，让co充当执行器这一个角色，也是个不错的解决方案<\/p>\n<p>千万别把generator叫成生成器，我们一般习惯把scaffold叫成生成器<\/p>\n<p>app-generator.js<\/p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst app = new Koa();\nconst co = require(&#x27;co&#x27;);\n\napp.use(co.wrap(function *(ctx, next) {\n  const start = new Date();\n  yield next();\n  const ms = new Date() - start;\n  console.log(&#96;${ctx.method} ${ctx.url} - ${ms}ms&#96;);\n}));\n\n&#x2F;&#x2F; response\napp.use(ctx =&gt; {\n  ctx.body = &#x27;Hello Koa  in app-generator.js&#x27;;\n});\n\napp.listen(3000);\n<\/code><\/pre><h3>测试<\/h3>\n<p>启动执行<\/p>\n<pre class=\"prettyprint\"><code>npm i -g runkoa\n\nrunkoa app.js\nrunkoa app-async.js     \nrunkoa app-generator.js \n<\/code><\/pre><p>测试发起 http 请求<\/p>\n<pre class=\"prettyprint\"><code>$ curl http:&#x2F;&#x2F;127.0.0.1:3000\nHello Koa in app.js\n<\/code><\/pre><h2>v3将移除单纯的以generator作为中间件的写法<\/h2>\n<pre class=\"prettyprint\"><code>Old signature middleware (v1.x) support will be removed in v3\n<\/code><\/pre><p>实际是koa核心包含了一个叫koa-convert的模块，它里面warning说，以generator作为中间件的写法将在koa<a href=\"/user/3\">@3<\/a>里不支持<\/p>\n<p>但是用co或koa-convert转过的还是可以的，本文的3种写法都是长期支持的<\/p>\n<p>这样写不行。。。。<\/p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; Koa will convert\napp.use(function *(next) {\n  const start = new Date();\n  yield next;\n  const ms = new Date() - start;\n  console.log(&#96;${this.method} ${this.url} - ${ms}ms&#96;);\n});\n<\/code><\/pre><p>这样写是可以的<\/p>\n<pre class=\"prettyprint\"><code>const convert = require(&#x27;koa-convert&#x27;);\n\napp.use(convert(function *(next) {\n  const start = new Date();\n  yield next;\n  const ms = new Date() - start;\n  console.log(&#96;${this.method} ${this.url} - ${ms}ms&#96;);\n}));\n<\/code><\/pre><h2>Babel支持<\/h2>\n<p>我本人比较讨厌写babel，对于node sdk不支持的特性持观望态度，比如async/await这样的神器是可以用的，其他的是不一定一定要上的，那就观望好了<\/p>\n<p>如果在koa 2里用到async/await就需要babel支持了<\/p>\n<ul>\n<li>es2015-node5（nodejs 5.x里支持的es6特性）<\/li>\n<li>stage-3（包含async/await）<\/li>\n<\/ul>\n<p>可是，我还是不想用，就几行代码能搞定的事儿，我不想看到babel出现在我的代码里，于是就有了前面用到的runkoa，它的原理也是这样的，不过看起来更clean一些<\/p>\n<h2>总结<\/h2>\n<p>Node.js 4.x和5.x支持的es特性还是有很大差异的，如果不用到，还好，万一用到就只能babel去转换，还有就是async支持，必须要stage-3，那么也还是需要babel。<\/p>\n<pre class=\"prettyprint\"><code>Node.js sdk迟迟不更新很讨厌,babel更新太快也很讨厌\n<\/code><\/pre><p>但是，无论从性能，还是流程控制上，koa 2和它的后宫（中间件）都是非常好的解决方案<\/p>\n<p>全文完<\/p>\n<p>欢迎关注我的公众号【node全栈】<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FtALxsauUkYDGdzcuA5y6BaIdUMC\" alt=\"node全栈.png\"><\/p>\n<\/div>","title":"Koa 2实用入门","last_reply_at":"2016-09-14T02:15:34.627Z","good":true,"top":false,"reply_count":21,"visit_count":7587,"create_at":"2016-04-09T23:51:54.772Z","author":{"loginname":"i5ting","avatar_url":"https://avatars.githubusercontent.com/u/3118295?v=3&s=120"}},{"id":"56a1d827cd415452622eed07","author_id":"5546d7c4c5441de9545a3c30","tab":"share","content":"<div class=\"markdown-text\"><p>摘译自：<a href=\"https://strongloop.com/strongblog/higher-order-functions-in-es6easy-as-a-b-c/\">https://strongloop.com/strongblog/higher-order-functions-in-es6easy-as-a-b-c/<\/a>\n先来看下高阶函数定义：<\/p>\n<ul>\n<li>接受1个或多个函数作为参数<\/li>\n<li>返回函数类型<\/li>\n<\/ul>\n<p>常规ES6箭头函数用法：(返回值类型)\n<code>const square = x =&gt; x * x;<\/code>\n高阶写法：<\/p>\n<pre class=\"prettyprint\"><code>const has = p =&gt; o =&gt; o.hasOwnProperty(p);\nconst sortBy = p =&gt; (a, b) =&gt; a[p] &gt; b[p];\n<\/code><\/pre><h3>理解语法<\/h3>\n<p>ES5实现高阶函数，也叫柯里化：<\/p>\n<pre class=\"prettyprint\"><code>function add(x){\n  return function(y){\n    return y + x;\n  };\n}\n \nvar addTwo = add(2);\naddTwo(3);          &#x2F;&#x2F; =&gt; 5\nadd(10)(11);        &#x2F;&#x2F; =&gt; 21\n<\/code><\/pre><p>add函数接受x，返回一个函数接受y返回y＋x。如何用箭头函数实现同样功能呢？我们知道：<\/p>\n<ul>\n<li>箭头函数体是表达式，并且<\/li>\n<li>箭头函数隐式返回表达式<\/li>\n<\/ul>\n<p>所以为了实现高阶函数，我们可以使箭头函数的函数体为另一个箭头函数：<\/p>\n<pre class=\"prettyprint\"><code>const add = x =&gt; y =&gt; y + x;\n&#x2F;&#x2F; outer function: x =&gt; [inner function, uses x]\n&#x2F;&#x2F; inner function: y =&gt; y + x;\n<\/code><\/pre><p>这样我们可以创建一个绑定了x的内部函数：<\/p>\n<pre class=\"prettyprint\"><code>const add2 = add(2);&#x2F;&#x2F; returns [inner function] where x = 2\nadd2(4);            &#x2F;&#x2F; returns 6: exec inner with y = 4, x = 2\nadd(8)(7);          &#x2F;&#x2F; 15\n<\/code><\/pre><p>这个例子看起来没什么实际作用，但是很好的展示了如何在返回的函数中引用外部参数。<\/p>\n<h3>用户排序例子<\/h3>\n<pre class=\"prettyprint\"><code>const has = p =&gt; o =&gt; o.hasOwnProperty(p);\nconst sortBy = p =&gt; (a, b) =&gt; a[p] &gt; b[p];\n \nlet result;\nlet users = [\n  { name: &#x27;Qian&#x27;, age: 27, pets : [&#x27;Bao&#x27;], title : &#x27;Consultant&#x27; },\n  { name: &#x27;Zeynep&#x27;, age: 19, pets : [&#x27;Civelek&#x27;, &#x27;Muazzam&#x27;] },\n  { name: &#x27;Yael&#x27;, age: 52, title : &#x27;VP of Engineering&#x27;}\n];\n \nresult = users\n  .filter(has(&#x27;pets&#x27;))\n  .sort(sortBy(&#x27;age&#x27;));\n<\/code><\/pre><p>上述代码利用了Array的sort 和 filter 方法，这两个方法都接收一个函数参数，此处我们利用了箭头函数的高阶函数写法返回需要的函数。\n对比下直接传入函数的写法：<\/p>\n<pre class=\"prettyprint\"><code>result = users\n  .filter(x =&gt; x.hasOwnProperty(&#x27;pets&#x27;)) &#x2F;&#x2F;pass Function to filter\n  .sort((a, b) =&gt; a.age &gt; b.age);        &#x2F;&#x2F;pass Function to sort\n<\/code><\/pre><p>高阶函数写法：<\/p>\n<pre class=\"prettyprint\"><code>result = users\n  .filter(has(&#x27;pets&#x27;))  &#x2F;&#x2F;pass Function to filter\n  .sort(sortBy(&#x27;age&#x27;)); &#x2F;&#x2F;pass Function to sort\n<\/code><\/pre><h3>优势在哪？<\/h3>\n<ul>\n<li>减少代码重复<\/li>\n<li>提高代码重用性<\/li>\n<li>更容易阅读的代码<\/li>\n<\/ul>\n<p>假设我们想列出有pets和title的用户，可以采用如下传统写法：<\/p>\n<pre class=\"prettyprint\"><code>result = users\n  .filter(x =&gt; x.hasOwnProperty(&#x27;pets&#x27;))\n  .filter(x =&gt; x.hasOwnProperty(&#x27;title&#x27;))\n  ...\n<\/code><\/pre><p>采用高阶函数写法：<\/p>\n<pre class=\"prettyprint\"><code>result = users\n  .filter(has(&#x27;pets&#x27;))\n  .filter(has(&#x27;title&#x27;))\n  ...\n<\/code><\/pre><p>可以明显感受到高阶写法更容易写和维护。<\/p>\n<h3>更进一步<\/h3>\n<p>假设想实现一个过滤器函数完成如下功能：判断一个对象是否包含指定值的key。之前的has函数用于检查对象key，我们需要在此基础上加入值的检查：<\/p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;[p]roperty, [v]alue, [o]bject:\nconst is = p =&gt; v =&gt; o =&gt; o.hasOwnProperty(p) &amp;&amp; o[p] == v;\n \n&#x2F;&#x2F; broken down:\n&#x2F;&#x2F; outer:  p =&gt; [inner1 function, uses p]\n&#x2F;&#x2F; inner1: v =&gt; [inner2 function, uses p and v]\n&#x2F;&#x2F; inner2: o =&gt; o.hasOwnProperty(p) &amp;&amp; o[p] = v;\n<\/code><\/pre><p>所以我们的新函数is做了下面三件事：<\/p>\n<ul>\n<li>接收属性名返回函数\u2026<\/li>\n<li>接收值返回函数\u2026<\/li>\n<li>接收对象，并判读该对象是否有指定的属性名和值，并返回boolean<\/li>\n<\/ul>\n<p>下面是一个使用is函数的例子：<\/p>\n<pre class=\"prettyprint\"><code>const titleIs = is(&#x27;title&#x27;);\n&#x2F;&#x2F; titleIs == v =&gt; o =&gt; o.hasOwnProperty(&#x27;title&#x27;) &amp;&amp; o[&#x27;title&#x27;] == v;\n \nconst isContractor = titleIs(&#x27;Contractor&#x27;);\n&#x2F;&#x2F; isContractor == o =&gt; o.hasOwnProperty(&#x27;contractor&#x27;) &amp;&amp; o[&#x27;title&#x27;] == &#x27;Contractor&#x27;;\n \nlet contractors = users.filter(isContractor);\nlet developers  = users.filter(titleIs(&#x27;Developer&#x27;));\n \nlet user = {name: &#x27;Viola&#x27;, age: 50, title: &#x27;Actress&#x27;, pets: [&#x27;Zak&#x27;]};\nisEmployed(user);   &#x2F;&#x2F; true\nisContractor(user); &#x2F;&#x2F; false\n<\/code><\/pre><h3>关于命名习惯<\/h3>\n<p>下面的写法需要你花点时间去理解其含义：\n<code>const i = x =&gt; y =&gt; z =&gt; h(x)(y) &amp;&amp; y[x] == z;<\/code>\n使用一些更明确含义的参数命名：\n<code>const is = prop =&gt; val =&gt; obj =&gt; has(prop)(obj) &amp;&amp; obj[prop] == val;<\/code><\/p>\n<h3>继续<\/h3>\n<p>如果我们想进一步提供排序功能，但是仅改为降序排列，或者列出不包含某属性的用户，我们需要重新实现诸如 sortByDesc 和 notHas这样的新函数吗？答案是不需要，对于最终返回结果是boolean值的高阶函数，我们可以对其进行取反包装，如下：<\/p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;take args, pass them thru to function x, invert the result of x\nconst invert = x =&gt; (...args) =&gt; !x(...args);\nconst noPets = invert(hasPets);\n \nlet petlessUsersOldestFirst = users\n  .filter(noPets)\n  .sort(invert(sortBy(&#x27;age&#x27;)));\n<\/code><\/pre><h3>结论<\/h3>\n<p>函数式编程受到越来越多的重视，ES6的箭头函数提供了更简洁方便的JavaScript实现方式，如果你还没有看到这种方法的广泛使用，那么可以预见在未来几个月函数式编程会伴随ES6的普及变得更为流行。即使你不太喜欢这种方式，那么理解高阶函数也是非常有必要的。<\/p>\n<\/div>","title":"ES6 高阶箭头函数","last_reply_at":"2016-09-13T06:36:56.849Z","good":true,"top":false,"reply_count":14,"visit_count":2865,"create_at":"2016-01-22T07:20:07.221Z","author":{"loginname":"pfcoder","avatar_url":"https://avatars.githubusercontent.com/u/12227405?v=3&s=120"}},{"id":"565c4473d0bc14ae279399fe","author_id":"536c8a26cf699d365204c3f9","tab":"share","content":"<div class=\"markdown-text\"><h3>说明<\/h3>\n<p>最近感觉Vue.js很不错，就抽业余时间写了cnodejs社区的webapp,主要技术栈是Vue.js+webpack.\n由于是业余时间写的，很多东西都还在完善之中。\n目前由我和<a href=\"/user/yunkou\">@yunkou<\/a> 在一起维护，也欢迎大家提供宝贵点意见让我不断的优化该产品。<\/p>\n<h3>项目源码和线上地址<\/h3>\n<p><img src=\"//dn-cnode.qbox.me/FsxOZts38LzjsuQmuE0Y6MVMs8Iq\" alt=\"logo.png\">\n源码地址：<a href=\"https://github.com/shinygang/Vue-cnodejs\">https://github.com/shinygang/Vue-cnodejs<\/a>,\n线上访问地址：<a href=\"http://shinygang.github.io/cnodevue/\">http://shinygang.github.io/cnodevue/<\/a>.<\/p>\n<h3>运行截图：<\/h3>\n<p><img src=\"//dn-cnode.qbox.me/FldUkKLRz4xBBg3WyQb5m6e5WAin\" alt=\"1.pic.jpg\"> <img src=\"//dn-cnode.qbox.me/FgbYnwPmxVWGNh19yDKbAyua37SB\" alt=\"2.pic.jpg\"> <img src=\"//dn-cnode.qbox.me/FoKCEH54PJWg40-xqeU7IIruM3AP\" alt=\"3.pic.jpg\"><\/p>\n<h3>联系方式<\/h3>\n<p>微信: g-ganggege\n邮箱: <a href=\"mailto:429517385@qq.com\">429517385@qq.com<\/a>\n个人感觉Vue.js还不错，也希望大家推进Vue社区的发展。<\/p>\n<\/div>","title":"用Vue.js编写了cnodejs.org的h5客户端(webapp)","last_reply_at":"2016-09-12T08:44:26.824Z","good":true,"top":false,"reply_count":116,"visit_count":21180,"create_at":"2015-11-30T12:43:31.579Z","author":{"loginname":"shinygang","avatar_url":"https://avatars.githubusercontent.com/u/7077490?v=3&s=120"}},{"id":"5743ec28991011691ef17aae","author_id":"5157d04e5dff253b376d2b91","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>UPDATE\n详细介绍在这里 <a href=\"https://github.com/nihgwu/NeoReader\">https://github.com/nihgwu/NeoReader<\/a>\n<strong>[2016.9.9] v1.2.0 版本发布 <a href=\"https://cnodejs.org/topic/57d217c33d3520a5387c2b55\">https://cnodejs.org/topic/57d217c33d3520a5387c2b55<\/a><\/strong><\/p>\n<\/blockquote>\n<p><strong>牛读 - NeoReader<\/strong> 是一款定制的技术资讯类聚合阅读器，目前包括定制的 知乎日报、V2EX、CNODE、开发者头条、Github Trending、Hacker News、Reddit Programming。<\/p>\n<p><strong>为什么发在这，因为可以看CNODE啊，支持登录和回复，可以当半个客户端使用<\/strong><\/p>\n<p><strong>如果觉得 App 不错，请记得去 AppStore 好评哟<\/strong>（入口在关于界面，<em>怕你们找不到\u2026\u2026<\/em>）<\/p>\n<p>Android 版因为 React Native 的支持问题，相比 iOS 版有两个主要的区别：<\/p>\n<ul>\n<li>header 的 TabBar 自动跟随不够流畅（iOS用的原生方法处理）<\/li>\n<li><del>section header不能固定（这个比较影响体验，可能会采用第三方原生组件解决）<\/del><\/li>\n<li><del>暂时不支持 GIF<\/del><\/li>\n<\/ul>\n<p><a href=\"https://itunes.apple.com/cn/app/niu-du-neoreader/id1111443079?l=en&amp;mt=8\">iOS 版下载<\/a><\/p>\n<p><img src=\"https://raw.githubusercontent.com/nihgwu/NeoReader/master/qrcode.png\" alt=\"iOS 版下载\"><\/p>\n<p><a href=\"http://android.myapp.com/myapp/detail.htm?apkName=com.liteneo.reader\">Android 版下载<\/a><\/p>\n<p><img src=\"https://raw.githubusercontent.com/nihgwu/NeoReader/master/qrcode-android.png\" alt=\"Android 版下载\"><\/p>\n<h2>关于 NeoReader 的一些说明<\/h2>\n<ul>\n<li>采用 React Native 开发，没有任何后端，所以某些资源访问会比较慢，比如 V2EX，因为官方并未提供 tab 的 API，所以目前是采用实时爬取得手机页面，解析 DOM，然后使用 Native View 渲染出来，这个过程可能会稍微有点耗时，如果有后台爬取提供API会好很多，但是我目前并不想做后台<\/li>\n<li>关于数据刷新机制，目前只有在 WIFI 环境才会自动刷新，否则必须手动下拉更新数据，而且只会更新当前页面，所以第一次使用的时候其他页面内容都是空的（早期是全部更新，但是会影响启动体验，而且并不合理）<\/li>\n<li>对于方便解析的页面内容，都是采用解析 DOM 然后用 Native View 渲染，包括 知乎日报、V2EX、CNODE、Hacker News，开发者头条因为内容源多变，没办法做解析，Github Trending 没时间处理目前也是用WebView打开，后面会做专门的Native页面<\/li>\n<li>访问 CNODE 某些帖子闪退的问题，其实是有一篇帖子的GIF图片过大，然后 React Native 的 GIF 解析有 bug，所以造成内存占用过大而闪退<\/li>\n<li>Hacker News 加载很慢，因为 HN 官方 API 的特殊性，列表需要多个请求才能完成，而且在国外，所以更新会稍慢，进入详情页面是直接用 WebView 打开这个链接，更慢，点击后面的回复可以查看回复列表，目前采用了分级加载的策略，会稍微好点<\/li>\n<li>目前 Android 版没有针对 Android6.0 优化<\/li>\n<li><strong>关于大家关心的权限问题<\/strong>，大家尽可以放心，除了处理资讯，没有做任何其他动作，如果提示需要一些电话之类的权限，可能是因为添加的分享模块需要<\/li>\n<\/ul>\n<h2>截图<\/h2>\n<p><img src=\"http://a2.mzstatic.com/us/r30/Purple18/v4/92/14/cb/9214cb49-ada5-b1ad-9e28-b070ad510dc7/screen696x696.jpeg\" alt=\"1\">\n<img src=\"http://a3.mzstatic.com/us/r30/Purple20/v4/86/b0/a1/86b0a14d-e2a8-eb6d-714e-8ced4bc46031/screen696x696.jpeg\" alt=\"2\">\n<img src=\"http://a5.mzstatic.com/us/r30/Purple30/v4/62/ba/81/62ba81f9-1e89-9325-24de-709ca5c60208/screen696x696.jpeg\" alt=\"3\">\n<img src=\"http://a5.mzstatic.com/us/r30/Purple30/v4/c1/e8/4c/c1e84cb4-a778-e4c7-d031-be3304741147/screen696x696.jpeg\" alt=\"4\"><\/p>\n<h2>DEMO<\/h2>\n<p><img src=\"https://github.com/nihgwu/NeoReader/raw/master/reader1.gif\" alt=\"reader1.gif\">\n<img src=\"https://github.com/nihgwu/NeoReader/raw/master/reader2.gif\" alt=\"reader2.gif\"><\/p>\n<\/div>","title":"牛读 - NeoReader，一款定制的技术资讯类聚合阅读器","last_reply_at":"2016-09-12T07:46:58.595Z","good":true,"top":false,"reply_count":33,"visit_count":1878,"create_at":"2016-05-24T05:52:40.186Z","author":{"loginname":"nihgwu","avatar_url":"https://avatars.githubusercontent.com/u/2595058?v=3&s=120"}},{"id":"5703584e8265278d59c7e4f2","author_id":"4efc278725fa69ac6900072b","tab":"job","content":"<div class=\"markdown-text\"><p>状态：持续招人中。。。<\/p>\n<h3>【关于公司】<\/h3>\n<p><a href=\"http://www.dji.com\">DJI 大疆创新<\/a>是世界上最热门的消费级无人机生产商，<a href=\"http://tech2ipo.com/96261\">2015 年销售额破 10 亿美元<\/a>，估值近 100 亿美元。网上有很多大疆的介绍我这里不多重复，我说说我个人的看法：你现在可能觉得大疆是一家无人机公司，但在未来，大疆不仅仅只是一家无人机公司，更大可能会成为一家机器人公司，一家高度智能的消费级机器人公司；现在的手机属于智能设备中的最常用的一种，但它只能在二维的空间运动，假如无人机变成了智能设备、机器人呢？整个三维的空间都是畅通无阻的，这里面就会有很大的想像空间。<\/p>\n<p>投资项目、投资股票我们都知道要选择黑马来投资，收获才是最快的、最大的，其实选择就业公司也是一样的，只不过我们投入的不是金钱，而是我们宝贵的青春，大疆无疑是最为强悍的黑马之一，这匹黑马身上还有三个隐形的标签：机器人、三维的、全球的。<\/p>\n<p><img src=\"http://cdn.pingwest.com/wp-content/uploads/2015/11/motion-painting-dji.gif-750x0\" alt>\n图为《神盾局特工》中 Daisy 的扮演者 Chloé Wang 来向大家展示了一个利用无人机 Phantom X 进行空中彩绘的场景。<\/p>\n<h3>【关于团队】<\/h3>\n<p>我们团队一直在探索着各种与互联网跨界融合的方式，移动互联网、云计算、大数据、物联网、电子商务都是团队不断创新的方向。 在这个过程，我们的前端工程师会承担各个系统的前端开发，以及大前端整体架构的搭建，新的项目也大都采用前后端分离的架构。<\/p>\n<ul>\n<li>我们采用 Scrum 方法论来进行敏捷开发，每两周作为一次冲刺，结束时会有回顾会议，讨论如何做得更好；<\/li>\n<li>我们借鉴了 Github 团队的工作方式，代码以 PR 的方式提交并进行 review；<\/li>\n<li>我们会进行 daily code review，随机抽取一小块代码进行 review，大家一起讨论改进的方法，现场进行重构，很好玩；<\/li>\n<li>我们在一些项目中实践了全自动化的部署方式，代码提交后自动运行测试，绿了 Jenkins 会直接发布到线上，这些能提高效率的事情我们最喜欢做；<\/li>\n<li>我们鼓励工程师学习最新最酷的技术，Microservice、Docker、 React 都已经逐步在小范围使用；<\/li>\n<li>我们现有的前端工程师，有来自于阿里、腾讯、百度等知名的企业，也有一些来自于互联网初创公司、独立开发者；<\/li>\n<li>我们非常重视团队精神的建设，遇到问题可以随时向其他工程师寻找帮助，探讨最佳的解决方法，也可以一起结对编程；<\/li>\n<li>我们每两周会组织一次内部技术分享会，各种主题都有，上一次有同学分享了《Python 大数据分析》，可以看到我们的无人机在地球上各大洲的足迹，非常有趣；<\/li>\n<\/ul>\n<h3>【福利待遇】<\/h3>\n<ol>\n<li><strong>每年都有机会获得配股<\/strong>，15 年底大概有 30% 的员工获得配股；华为作为实施全员持股的公司，有 15 万名员工，8 万人持股，持股比例逐年扩大后，现在是 53%；大疆现在有近 3000 人，2 年前 500 人，增长 6 倍，按此增长比例可以简单估算下 2 年后的持股人数。<\/li>\n<li>年终丰厚奖金；<\/li>\n<li>月薪 15-30k；<\/li>\n<li>其他的还有弹性工作制、健身房冲凉房洗衣房、国际幼儿园、各国零食、各种公积金保险以及可选员工小区住宿等；<\/li>\n<\/ol>\n<p>具体请以 HR 的说明为准。<\/p>\n<h3>【职位信息】<\/h3>\n<p>前端工程师 3 名<\/p>\n<p>招聘要求：<\/p>\n<ol>\n<li>本科及以上学历，至少 1 年以上 Web 前端开发经验，有 Node 开发经验者加分；<\/li>\n<li>精通 HTML, CSS, JavaScript 等 Web 前端技术，熟悉 W3C 网页标准；<\/li>\n<li>理解 AJAX 运作机制，熟悉常见前端框架（例如 jQuery, Backbone, React, Bootstrap），具备通过阅读框架源码解决特定问题的能力；<\/li>\n<li>熟悉 HTTP 协议，熟悉 Web 工作原理；<\/li>\n<li>具有跨平台开发经验，了解各浏览器 JavaScript 差异及处理方案；<\/li>\n<li>有大用户量访问网站页面优化经验优先考虑。<\/li>\n<\/ol>\n<h3>【联系方式】<\/h3>\n<p>简历请发至 <a href=\"http://saber.ma#dji.com\">saber.ma#dji.com<\/a> ，我会在当天回复，合适的话当天内推。<\/p>\n<p>如果有任何疑问可以提问，我尽量回答。<\/p>\n<\/div>","title":"[深圳] DJI 大疆创新 Q1 招聘前端工程师 3 名（内推 15-30k + 全员持股）","last_reply_at":"2016-09-12T02:42:02.876Z","good":true,"top":false,"reply_count":95,"visit_count":9013,"create_at":"2016-04-05T06:16:46.437Z","author":{"loginname":"saberma","avatar_url":"//gravatar.com/avatar/871c4ba6d25169779cee977e04b2f0c3?s=48"}},{"id":"5716137fe84805cd5410ea21","author_id":"56e3bb11f5d830306e2f0fd1","tab":"share","content":"<div class=\"markdown-text\"><h4>声明：转载请保留声明头部并标明转载、并私信告知作者。原文：<a href=\"http://www.cnblogs.com/papertree/p/5398008.html\">http://www.cnblogs.com/papertree/p/5398008.html<\/a><\/h4>\n<p>我们在第3-5篇博客讲了js代码如何调用到C++接口的机制，其中暗含的require、process.binding这些过程。<\/p>\n<p>这篇博客以server.listen(80)为例，讲这两点：<\/p>\n<ol>\n<li>\n<p>js代码深入、作用到libuv事件循环的过程【1.1节的问题2】<\/p>\n<\/li>\n<li>\n<p>libuv事件循环本身的过程【1.1节的问题3】<\/p>\n<\/li>\n<\/ol>\n<h3>6.1 js到事件循环 \u2014\u2014 数据结构<\/h3>\n<h4>6.1.1事件循环的核心数据结构 \u2014\u2014 struct uv_loop_s default_loop_struct;<\/h4>\n<p>还记得2.2节的流程图吗，js代码里面执行网络io操作，最终保存一个io观察者到default_loop_struct，在node进入事件循环的时候，再获取io观察者进行监听。<\/p>\n<p>来看看struct uv_loop_s 的结构体定义：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FsWcM9saTYh4pxqTpUu72UF7oAG3\" alt=\"6-1-1（3）.png\"><\/p>\n<center>图6-1-1<\/center>\n<p>在这篇博客里主要关系的是watcher_queue、watchers、nwatchers、nfds这四个成员。<\/p>\n<p>watcher_queue：io观察者链表，链表原理看6.4节。<\/p>\n<p>watchers：是一个uv__io_t 类型的二级指针。这里维护的是一个io观察者映射表【实际是以fd为下标索引的数组】。<\/p>\n<p>nwatchers：watchers数组的size，因为是堆分配的动态数组，所以需要维护数组的长度。<\/p>\n<p>nfds：监听了多少个fd，不同于nwatchers，因为watchers里面很多元素是空的。<\/p>\n<p>【注：c语言里面经常会有 \u201ctypedef struct uv_loop_s uv_loop_t\u201d、\u201ctypedef struct uv__io_s uv__io_t\u201d这种写法去给结构体类型起别名，这样的好处是用uv_loop_s去定义一个变量需要加上struct，而通过typedef的别名不用，比如：<\/p>\n<p>struct uv_loop_s default_loop_struct;\nuv_loop_t default_loop_struct;\n这两种写法是一样的。】<\/p>\n<h4>6.1.2 io观察者结构体 \u2014\u2014 struct uv__io_s<\/h4>\n<p>6.1.1中看到，我们的网络io操作最终会封装成一个io观察者，保存到default_loop_struct的io观察者映射表\u2014\u2014watchers 里面。<\/p>\n<p>来看一下封装的io观察者的定义：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/Fg9y9rWST9ogTJK6_Q-rZMCrRmzM\" alt=\"6-1-2.png\"><\/p>\n<center>图6-1-2<\/center>\n<p>可以看到一个io观察者封装了：<\/p>\n<p>fd：文件描述符，操作系统对进程监听的网络端口、或者打开文件的一个标记<\/p>\n<p>cb：回调函数，当相应的io观察者监听的事件被激活之后，被libuv事件循环调用的回调函数<\/p>\n<p>events：交给libuv的事件循环（epoll_wait）进行监听的事件<\/p>\n<h4>6.1.3 持有io观察者的结构体 \u2014\u2014 比如struct uv_tcp_s<\/h4>\n<p>io观察者结构体（uv__io_s） 是我们调用server.listen()之后，与libuv事件循环的交互数据。<\/p>\n<p>事件循环数据结构default_loop_struct 维护uv__io_s的映射表 \u2014\u2014 watchers成员。<\/p>\n<p>而用户的每一个io操作流程，最终也通过某个结构体来持有这个io观察者。比如当进行tcp的 io操作时，其对应的io观察者，由uv_tcp_s 结构体的 io_watcher成员持有：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FgIHnKaJALwaND73EaUWidqMTmIz\" alt=\"6-1-3.png\"><\/p>\n<center>图6-1-3<\/center>\n<h3>6.2 js到事件循环 \u2014\u2014 流程<\/h3>\n<p>6.1节讲了几个结构体和数据类型。这一节以这几行示例代码，介绍从js代码的io操作到保存io观察者的流程：<\/p>\n<pre class=\"prettyprint\"><code>var http = require(&#x27;http&#x27;);\n\nfunction requestListener(req, res) {\n    res.end(&#x27;hello world&#x27;);\n}\n\nvar server = http.createServer(requestListener);\nserver.listen(80);\n<\/code><\/pre><center>代码6-2-1<\/center>\n<p>其实这里http模块里面做的事情很简单，6-2-1示例代码等效于：<\/p>\n<pre class=\"prettyprint\"><code>const Server = require(&#x27;_http_server&#x27;).Server;\n\nfunction requestListener(req, res) {\n    res.end(&#x27;hello world&#x27;);\n}\n\nvar server = new Server(requestListener);\nserver.listen(80);\n<\/code><\/pre><center>代码6-2-2<\/center>\n<p>面向用户的接口仅仅是一个requestListener回调函数、监听端口，那么调用server.listen(80)之后，经过多少个环节才形成一个io观察者？io观察者的回调函数被调用之后，又经过多少个环节才回调到用户的requestListener？<\/p>\n<p>来看下有多少层：<\/p>\n<h4>6.2.1 http层Server类 \u2014\u2014 lib/_http_server.js<\/h4>\n<p>上述示例代码直接交互的是http Server类，看代码：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/Fnuh7Xi0feqcXePRHuF5YpZfRtr8\" alt=\"6-2-1 (2).png\"><\/p>\n<center>图6-2-1<\/center>\n<p>A. 设置环节 \u2014\u2014 requestListener<\/p>\n<p>当用户new Server产生一个server对象时，server添加\u2019request\u2019事件监听器。<\/p>\n<p>B. 回调环节 \u2014\u2014 connectionListener<\/p>\n<p>可以看到http层的Server类继承了socket层（net.js）的Server类。并添加\u2019connection\u2019事件监听器，当有连接到来时，由socket层的Server类发射\u2019connection\u2019事件，http层connectionListener被调用，拿到来自socket层的一个socket对象，进行跟http协议相关的处理，把http请求相关的数据封装成req、res两个对象，emit 'request\u2019事件，把req、res传给用户的requestListener回调函数。<\/p>\n<h4>6.2.2 socket层Server类 \u2014\u2014 lib/net.js<\/h4>\n<p>net.Server是负责socket层的Server类，也是http.Server的基类：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/Fhm9Ja0eJ219fQbPQJaGMBufU_Tf\" alt=\"6-2-2.png\"><\/p>\n<center>图6-2-2<\/center>\n<p>A. listen环节 \u2014\u2014 'connection\u2019事件<\/p>\n<p>在执行listen操作时，socket层Server类给self._handle.onconnection赋上回调函数。self._handle是更下层的TCP类对象。<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FmLOfYFtnzNkwFKphWuqc7ZOZptq\" alt=\"6-2-3.png\"><\/p>\n<center>图6-2-3<\/center>\n<p>B. 回调环节 \u2014\u2014 onconnection函数<\/p>\n<p>当有连接到来时，底层回调了TCP类的onconnection函数（self._handle.onconnection），并传过来一个clientHandle，onconnection把clientHandle封装成socket对象，并发射\u2019connection\u2019事件，把socket传给上层的connectionListener监听器。<\/p>\n<h4>6.2.3 node C++层TCP类 \u2014\u2014 src/tcp_wrap.cc<\/h4>\n<p>上面说到socket层的Server类与下层的交互是通过this._handle \u2014\u2014 TCP类对象。【注意了TCP不是C++本身的类，而是C++用来表示js类的 FunctionTemplate】<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FuqW57plZFvMNEE7j7PqbnuuHihT\" alt=\"6-2-4.png\"><\/p>\n<center>图6-2-4<\/center>\n<p>A. listen环节 \u2014\u2014 TCPWrap::OnConnection<\/p>\n<p>看到TCP这一层，执行listen时传给下层的回调函数是TCPWrap::OnConnection，而且可以看到与这一层交互的下一层就是libuv的接口了 \u2014\u2014 uv_listen。<\/p>\n<p>B. 回调环节 \u2014\u2014 onconnection<\/p>\n<p>上面讲到socket层Server类通过self._handle.onconnection = onconnection去设置回调函数。<\/p>\n<p>这一层可以看到onconnection函数在TCPWrap::OnConnection里面通过tcp_wrap-&gt;MakeCallback去回调。<\/p>\n<p>关于MakeCallback的实现在AsyncWrap类 \u2014\u2014 TCPWrap的基类：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FmWuzWQFGl8sKbmwbu-Gt0REvFmz\" alt=\"6-2-5.png\"><\/p>\n<center>图6-2-5<\/center>\n<p>这里有一行重要的代码 env() -&gt; tick_callback_function() -&gt; Call()。里面确保了当每次从C++陷入js领域、执行完js代码之后，会执行到诸如process.nextTick()设置的回调函数。<\/p>\n<p>通过2.2节我们可以知道，执行js代码只有两个时机：<\/p>\n<ol>\n<li>\n<p>刚启动的时候执行app.js文件<\/p>\n<\/li>\n<li>\n<p>异步回调函数被触发（注意回调函数有可能是被同步回调的）<\/p>\n<\/li>\n<\/ol>\n<p>那么这里的AsyncWrap::MakeCallback()就是每次执行js异步回调函数时，从C++域陷入js域的位置。<\/p>\n<h4>6.2.4 libuv层 uv_tcp_t结构体 \u2014\u2014 deps/uv/src/unix/tcp.c<\/h4>\n<p>在app.js里面的server.listen(80)，通过http.Server -&gt; net.Server -&gt; TCPWrap，终于到达了libuv层。这一层，我们看到6.1节的数据结构的使用细节。关于io观察者如何被保存、如何被事件循环取出使用的细节，我们看6.3节。<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FtPfYZe1kZaKmQzFOd7P5PUgM2hM\" alt=\"6-2-6.png\"><\/p>\n <center>图6-2-6<\/center>\n<p>看到uv_tcp_listen操作，通过调用uv__io_start 把自身的io_watcher（定义在6.1.2节）注册进tcp-&gt;loop（理解成6.1.1节里面的default_loop_struct \u2014\u2014 事件循环的数据结构）。<\/p>\n<p>这里注意到，从上层传过来的cb（TCPWrap::OnConnection）保存在了tcp-&gt;connection_cb，而tcp-&gt;io_watcher.cb 保存的是 uv__server_io。<\/p>\n<p>当有连接到来时，事件循环直接调用的cb是io_watcher里面的uv__server_io，里面先执行uv__accept等操作，再回调到stream-&gt;connection_cb。【注意到右边文件的stream-&gt;connection_cb实际上就是左边文件的tcp-&gt;connection_cb，uv_stream_t可以理解成uv_tcp_t的一个基类】<\/p>\n<h3>6.3 事件循环与io观察者<\/h3>\n<h4>6.3.1 io观察者的保存<\/h4>\n<p>6.2.4节讲到libuv层封装了io观察者，通过uv__io_start，把io观察者保存到指定的事件循环数据结构 \u2014\u2014 loop。来看看uv__io_start的细节：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FpskEidvXvaBkf3rUOhc31R8UuzS\" alt=\"6-3-1.png\"><\/p>\n<center>图6-3-1<\/center>\n<p>这里的loop就是6.1.1节中的事件循环数据结构体，w就是6.1.2节中的io观察者结构体。<\/p>\n<p>可以看到，添加一个io观察者需要两步操作：<\/p>\n<ol>\n<li>\n<p>使用QUEUE_INSERT_TAIL 往loop-&gt;watcher_queue 添加io观察者，链表原理看6.4节。<\/p>\n<\/li>\n<li>\n<p>把io观察者保存在loop-&gt;watchers中 \u2014\u2014 以fd为索引的数组。loop-&gt;watchers实际上类似于映射表的功能，而不是观察者队列。<\/p>\n<\/li>\n<\/ol>\n<h4>6.3.2 事件循环的核心 \u2014\u2014 io观察者的取出与回调<\/h4>\n<p>在2.2节的运行流程中知道事件循环最终调用了uv_run()进入了epoll_wait()等待，而uv_run的这个事件循环是调用了uv__io_poll()，那么来看看这个最终的循环：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/Fhxgk1ihcFvQCgluD-SHNU0len-I\" alt=\"6-3-2.png\"><\/p>\n<center>图6-3-2<\/center>\n<p>通过2.2节的运行流程，我们知道在js代码里面添加一个io观察者（比如调用server.listen()）是先通过保存io观察者（uv__io_t 结构体）到uv_loop_t结构体的watcher_queue里面，而不是马上注册到epoll_wait()进行监听的。<\/p>\n<p>当js代码执行完毕，进入C++域，再进入到uv__io_poll的时候，就需要这几个步骤：<\/p>\n<ol>\n<li>\n<p>遍历 loop-&gt;watcher_queue，取出所有io观察者，这里取出的w就是图6-3-1中调用uv__io_start保存的io观察者 \u2014\u2014 w。<\/p>\n<\/li>\n<li>\n<p>取出了w之后，调用epoll_ctl()，把w-&gt;fd（io观察者对应的fd）注册给系统的epoll机制，那么epoll_wait()时就监听对应的fd。<\/p>\n<\/li>\n<li>\n<p>当epoll_wait()返回了，拿出有事件到来的fd，这个时候loop-&gt;watchers 映射表就起到作用了，通过fd拿出对应的io观察者 \u2014\u2014 w，调用w-&gt;cb()。<\/p>\n<\/li>\n<\/ol>\n<h4>6.3.3 setTimeout \u2014\u2014 epoll_wait的timeout<\/h4>\n<p>看到epoll_wait有个timeout参数，这里正是setTimeout的原理。试想一下，epoll_wait所监听的所有io观察者对应的fd都没有事件触发，而setTimeout所设置的timeout到达了，那么epoll_wait()也是需要返回，让setTimeout的回调函数能够得以运行的。<\/p>\n<h3>6.4 io观察者链表<\/h3>\n<p>注意到4个点：<\/p>\n<ol>\n<li>\n<p>uv_loop_t 结构体的io观察者链表是void* [2]类型的watcher_queue来维护。<\/p>\n<\/li>\n<li>\n<p>uv__io_t（io观察者） 结构体也拥有一个void* watcher_queue[2]。<\/p>\n<\/li>\n<li>\n<p>在uv__io_start里面，通过QUEUE_INSERT_TAIL宏，往loop-&gt;watcher_queue里面添加w-&gt;watcher_queue，而不是w（io观察者本身）。<\/p>\n<\/li>\n<li>\n<p>在uv__io_poll里面，通过QUEUE_HEAD宏，从loop-&gt;watcher_queue里面取出元素 q，这个q事实上只是w-&gt;watcher_queue字段，需要通过QUEUE_DATA宏，从q去取出w。<\/p>\n<\/li>\n<\/ol>\n<p>【这跟c语言结构体的内存模型有关，可以通过一个成员的地址减去结构体内成员的偏移量，计算出结构体的在进程空间的内存地址。这也是QUEUE_DATA宏所做的事。】<\/p>\n<p>可以先来看看这几个宏的定义：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/Fl_6UUoCAOlWYOZAesFjEusXAzr7\" alt=\"6-4-1.png\"><\/p>\n<center>图6-4-1<\/center>\n<p>我们来看看下面这个图，第一个状态是uv_loop_t和两个uv__io_t里的watcher_queue成员执行了QUEUE_ININ之后的状态。<\/p>\n<p>第二、三个状态是依次通过QUEUE_INSERT_TAIL宏往uv_loop_t的watcher_queue里面添加uv__io_t的watcher_queue之后的状态。<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FpoUXDXXMLkrDwX46s9RvtrFI2Z0\" alt=\"io观察者链表 (2).png\"><\/p>\n<center>图6-4-2<\/center><\/div>","title":"node源码详解（六） \u2014\u2014 从server.listen 到事件循环","last_reply_at":"2016-09-12T01:28:52.759Z","good":true,"top":false,"reply_count":14,"visit_count":1801,"create_at":"2016-04-19T11:16:15.676Z","author":{"loginname":"bigtree9307","avatar_url":"https://avatars.githubusercontent.com/u/17524799?v=3&s=120"}},{"id":"516526766d38277306c7d277","author_id":"515434625dff253b3731e480","tab":"share","content":"<div class=\"markdown-text\"><p><em>囧，cnodejs不能上传图。有图版请见 <a href=\"http://blog.csdn.net/lhfcws/article/details/8783553\">无图无真相！<\/a><\/em><\/p>\n<p>NodeJS里最常用的测试框架估计就是mocha了。它支持多种node的assert libs， 同时支持异步和同步的测试，同时支持多种方式导出结果，也支持直接在browser上跑Javascript代码测试。<\/p>\n<p>本文示例大多源于官网示例，部分示例结合需要或自己的感想有所改动。更多介绍请看 官方网址：<a href=\"http://visionmedia.github.io/mocha/\">Mocha on Github<\/a><\/p>\n<h2>Installation：<\/h2>\n<p>当你成功安装nodejs v0.10 和 npm后执行下面这条命令。<\/p>\n<pre class=\"prettyprint\"><code># npm install -g mocha\n<\/code><\/pre><p>p.s. Ubuntu的注意apt源里的nodejs版本会比较旧，某些module会不支持，请从nodejs官网进行源码安装。<\/p>\n<h2>First step to Mocha：<\/h2>\n<p>以下为最简单的一个mocha示例：<\/p>\n<pre class=\"prettyprint\"><code>var assert = require(&quot;assert&quot;);\ndescribe(&#x27;Array&#x27;, function(){\n\tdescribe(&#x27;#indexOf()&#x27;, function(){\n  \t\tit(&#x27;should return -1 when the value is not present&#x27;, function(){\n        \tassert.equal(-1, [1,2,3].indexOf(5));\n\t\t    assert.equal(-1, [1,2,3].indexOf(0));\n\t\t})\n\t})\n});\n<\/code><\/pre><ul>\n<li><strong>describe (moduleName, testDetails)<\/strong> \t\t\n由上述代码可看出，describe是可以嵌套的，比如上述代码嵌套的两个describe就可以理解成测试人员希望测试Array模块下的#indexOf() 子模块。module_name 是可以随便取的，关键是要让人读明白就好。<\/li>\n<li><strong>it (info, function)<\/strong> \t\t\n具体的测试语句会放在it的回调函数里，一般来说info字符串会写期望的正确输出的简要一句话文字说明。当该it block内的test failed的时候控制台就会把详细信息打印出来。一般是从最外层的describe的module_name开始输出（可以理解成沿着路径或者递归链或者回调链），最后输出info，表示该期望的info内容没有被满足。<strong>一个it对应一个实际的test case<\/strong><\/li>\n<li><strong>assert.equal (exp1, exp2)<\/strong> \t\t\n断言判断exp1结果是否等于exp2, 这里采取的等于判断是== 而并非 === 。即 assert.equal(1, \u20181\u2019) 认为是True。这只是nodejs里的assert.js的一种断言形式，下文会提到同样比较常用的should.js。<\/li>\n<\/ul>\n<p>如果exp1和exp2均为字符串，字符串比较出错时则控制台会用颜色把相异的部分标出来。<\/p>\n<h2>Asynchronous<\/h2>\n<p>Frist step 中的代码显然是个 Synchronous 的代码，那么对于异步代码应该怎么做呢？很简单，在你最深处的回调函数中加done()表示结束。<\/p>\n<pre class=\"prettyprint\"><code>fs = require(&#x27;fs&#x27;);\ndescribe(&#x27;File&#x27;, function(){\n\tdescribe(&#x27;#readFile()&#x27;, function(){\n    \tit(&#x27;should read test.ls without error&#x27;, function(done){\n\t    \tfs.readFile(&#x27;test.ls&#x27;, function(err){\n\t\t\t\tif (err) throw err;\n\t\t\t\tdone();\n\t\t\t});\n\t\t})\n\t})\n})\n<\/code><\/pre><ul>\n<li><strong>done ()<\/strong><br>\n按照瀑布流编程习惯，取名done是表示你回调的最深处，也就是结束写嵌套回调函数。但对于回调链来说done实际上意味着告诉mocha从此处开始测试，一层层回调回去。<\/li>\n<\/ul>\n<p>上例代码是test pass的，<a href=\"http://xn--test-965fu21e0qjz1ai23y.xn--lstest-xp7is53dw1inprigi777c.as\">我们尝试把test.ls改成不存在的test.as<\/a>。便会返回具体的错误位置。<\/p>\n<p>这里可能会有个疑问，假如我有两个异步函数（两条分叉的回调链），那我应该在哪里加done()呢？实际上这个时候就不应该在一个it里面存在两个要测试的函数，事实上<strong>一个it里面只能调用一次done<\/strong>，当你调用多次done的话mocha会抛出错误。所以应该类似这样：<\/p>\n<pre class=\"prettyprint\"><code>fs = require(&#x27;fs&#x27;);\ndescribe(&#x27;File&#x27;, function(){\n\tdescribe(&#x27;#readFile()&#x27;, function(){\n    \tit(&#x27;should read test.ls without error&#x27;, function(done){\n\t    \tfs.readFile(&#x27;test.ls&#x27;, function(err){\n\t\t\t\tif (err) throw err;\n\t\t\t\tdone();\n\t\t\t});\n\t\t})\n    \tit(&#x27;should read test.js without error&#x27;, function(done){\n\t    \tfs.readFile(&#x27;test.js&#x27;, function(err){\n\t\t\t\tif (err) throw err;\n\t\t\t\tdone();\n\t\t\t});\n\t\t})\n\t})\n})\n<\/code><\/pre><h2>Pending<\/h2>\n<p>即省去测试细节只保留函数体。一般适用情况比如负责测试框架的写好框架让组员去实现细节，或者测试细节尚未完全正确实现先注释以免影响全局测试情况。这种时候mocha会默认该测试pass。\n作用有点像Python的pass。<\/p>\n<pre class=\"prettyprint\"><code>describe(&#x27;Array&#x27;, function(){\n\tdescribe(&#x27;#indexOf()&#x27;, function(){\n  \t\tit(&#x27;should return -1 when the value is not present&#x27;, function(){\n\t\t})\n\t})\n});\n<\/code><\/pre><h2>Exclusive &amp;&amp; Inclusive<\/h2>\n<p>其实很好理解，分别对应only和skip函数。<\/p>\n<pre class=\"prettyprint\"><code>fs = require(&#x27;fs&#x27;);\ndescribe(&#x27;File&#x27;, function(){\n\tdescribe(&#x27;#readFile()&#x27;, function(){\n    \tit.skip(&#x27;should read test.ls without error&#x27;, function(done){\n\t    \tfs.readFile(&#x27;test.ls&#x27;, function(err){\n\t\t\t\tif (err) throw err;\n\t\t\t\tdone();\n\t\t\t});\n\t\t})\n    \tit(&#x27;should read test.js without error&#x27;, function(done){\n\t\t})\n\t})\n})\n<\/code><\/pre><p>上面的代码只会有一个test complete， 只有only的会被执行，另一个会被忽略掉。<strong>每个函数里只能有一个only<\/strong>。如果是it.skip ，那么该case就会被忽略。<\/p>\n<p>only和skip共用没有什么实际意义，因为only的作用会把skip屏蔽掉。<\/p>\n<pre class=\"prettyprint\"><code>fs = require(&#x27;fs&#x27;);\ndescribe(&#x27;File&#x27;, function(){\n\tdescribe(&#x27;#readFile()&#x27;, function(){\n    \tit.skip(&#x27;should read test.ls without error&#x27;, function(done){\n\t    \tfs.readFile(&#x27;test.as&#x27;, function(err){\n\t\t\t\tif (err) throw err;\n\t\t\t\tdone();\n\t\t\t});\n\t\t})\n    \tit(&#x27;should read test.js without error&#x27;, function(done){\n\t\t})\n\t})\n})\n<\/code><\/pre><p>上面的代码尽管test.as不存在，但是由于skip，依然会显示test complete。<\/p>\n<h2>Before &amp;&amp; After<\/h2>\n<p>单元测试里经常会用到before和after。mocha同时还提供了beforeEach()和afterEach()。\n这里为方便阅读用livescript表示，!-&gt;可理解成function(){}。细节无需细读，只需通过框架了解这几个函数如何使用便可。<\/p>\n<pre class=\"prettyprint\"><code>require! assert\nrequire! fs\ncan = it\n\n\ndescribe &#x27;Array&#x27;, !-&gt;\n\tbeforeEach !-&gt;\n\t\tconsole.log &#x27;beforeEach Array&#x27;\n\n\tbefore !-&gt;\n\t\tconsole.log &#x27;before Array&#x27;\n\t\n\tbefore !-&gt;\n\t\tconsole.log &#x27;before Array second time&#x27;\n\n\tafter !-&gt;\n\t\tconsole.log &#x27;after Array&#x27;\n\n\tdescribe &#x27;#indexOf()&#x27;, !-&gt;\n\t\tcan &#x27;should return -1 when the value is not present&#x27;, !-&gt;\n\t\t\tassert.equal -1, [1,2,3].indexOf 0\n\t\tcan &#x27;should return 1 when the value is not present&#x27;, !-&gt;\n\n\tdescribe &#x27;File&#x27;, !-&gt;\n\n\t\tbeforeEach !-&gt;\n\t\t\tconsole.log &#x27;beforeEach file test!&#x27;\n\n\t\tafterEach !-&gt;\n\t\t\tconsole.log &#x27;afterEach File test!&#x27;\n\n\t\tdescribe &#x27;#readFile()&#x27;, !-&gt;\n\t\t\tcan &#x27;should read test.ls without error&#x27;, !(done)-&gt;\n\t\t\t\tfs.readFile &#x27;test.ls&#x27;, !(err)-&gt;\n\t\t\t\t\tif err\n\t\t\t\t\t\tthrow err\n\t\t\t\t\tdone!\n\t\t\tcan &#x27;should read test.js without error&#x27;, !(done)-&gt;\n\t\t\t\tfs.readFile &#x27;test.js&#x27;, !(err)-&gt;\n\t\t\t\t\tif err\n\t\t\t\t\t\tthrow err\n\t\t\t\t\tdone!\n<\/code><\/pre><p>由结果可知(after的使用与before同理)，<\/p>\n<ul>\n<li>beforeEach会对当前describe下的所有子case生效。<\/li>\n<li>before和after的代码没有特殊顺序要求。<\/li>\n<li>同一个describe下可以有多个before，执行顺序与代码顺序相同。<\/li>\n<li>同一个describe下的执行顺序为before, beforeEach, afterEach, after<\/li>\n<li>当一个it有多个before的时候，执行顺序从最外围的describe的before开始，其余同理。<\/li>\n<\/ul>\n<h2>Test Driven Develop (TDD)<\/h2>\n<p>mocha默认的模式是Behavior Driven Develop (BDD)，要想执行TDD的test的时候需要加上参数，如<\/p>\n<pre class=\"prettyprint\"><code>mocha -u tdd test.js\n<\/code><\/pre><p>前文所讲的describe, it, before, after等都属于BDD的范畴，对于TDD，我们用suite, test, setup, teardown。样例代码如下:<\/p>\n<pre class=\"prettyprint\"><code>suite &#x27;Array&#x27;, !-&gt;\n\tsetup !-&gt;\n\t\tconsole.log &#x27;setup&#x27;\n\n\tteardown !-&gt;\n\t\tconsole.log &#x27;teardown&#x27;\n\n\tsuite &#x27;#indexOf()&#x27;, !-&gt;\n\t\ttest &#x27;should return -1 when not present&#x27;, !-&gt;\n\t\t\tassert.equal -1, [1,2,3].indexOf 4\n<\/code><\/pre><hr>\n### TDD的一些相关资料：\n1. **What is TDD** :\n<p><a href=\"http://stackoverflow.com/questions/2327119/what-is-test-driven-development-does-it-require-to-have-initial-designs\">http://stackoverflow.com/questions/2327119/what-is-test-driven-development-does-it-require-to-have-initial-designs<\/a><\/p>\n<ol>\n<li><strong>Difference between TDD &amp;&amp; BDD<\/strong> :<\/li>\n<\/ol>\n<p><a href=\"http://stackoverflow.com/questions/4395469/tdd-and-bdd-differences\">http://stackoverflow.com/questions/4395469/tdd-and-bdd-differences<\/a><\/p>\n<\/div>","title":"初识 mocha in NodeJS","last_reply_at":"2016-09-12T00:12:27.378Z","good":true,"top":false,"reply_count":37,"visit_count":36039,"create_at":"2013-04-10T08:44:38.807Z","author":{"loginname":"lhfcws","avatar_url":"//gravatar.com/avatar/19775e24394f727eb342154459370d20?size=48"}},{"id":"57c529cf9b447b634391c814","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>使用node-crawler和jsdom完成爬虫<\/h1>\n<h2>初衷<\/h2>\n<p>从天蚕土豆的《大主宰》Huge Dominate<\/p>\n<p>起点上是付费的，不经常看，偶尔看看而已，付费没啥意思。于是找免费的<\/p>\n<p><a href=\"http://www.biquku.com/0/330/\">http://www.biquku.com/0/330/<\/a><\/p>\n<p>即使说无弹窗，可是还是有很多广告。。。<\/p>\n<p>作为一个有追求的程序员能忍么？<\/p>\n<h2>node-crawler说明<\/h2>\n<p>爬取《大主宰》的所有章节列表<\/p>\n<p><img src=\"https://github.com/i5ting/simplereader/raw/master/docs/images/1.png\" alt=\"1\"><\/p>\n<pre class=\"prettyprint\"><code>var Crawler = require(&quot;crawler&quot;);\nvar jsdom = require(&#x27;jsdom&#x27;);\n\nvar c = new Crawler({\n    jQuery: jsdom,\n    maxConnections : 100,\n    forceUTF8:true,\n  &#x2F;&#x2F; incomingEncoding: &#x27;gb2312&#x27;,\n    &#x2F;&#x2F; This will be called for each crawled page\n    callback : function (error, result, $) {\n      var urls = $(&#x27;#list a&#x27;);\n      console.log(urls)\n    }\n});\n\nc.queue(&#x27;http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;&#x27;);\n<\/code><\/pre><p>执行<\/p>\n<pre class=\"prettyprint\"><code>node examples&#x2F;1&#x2F;hello-crawler.js\n<\/code><\/pre><h2>解析章节信息<\/h2>\n<p>代码<\/p>\n<pre class=\"prettyprint\"><code>var Crawler = require(&quot;crawler&quot;);\nvar jsdom = require(&#x27;jsdom&#x27;);\n\nvar current_book = { }\n\nvar c = new Crawler({\n    jQuery: jsdom,\n    maxConnections : 100,\n    forceUTF8:true,\n  &#x2F;&#x2F; incomingEncoding: &#x27;gb2312&#x27;,\n    &#x2F;&#x2F; This will be called for each crawled page\n    callback : function (error, result, $) {\n      var urls = $(&#x27;#list a&#x27;);\n      &#x2F;&#x2F; console.log(urls)\n      \n      \n      current_book.title = $(&#x27;#maininfo h1&#x27;).text()\n      current_book.author = $(&#x27;#info p&#x27;).eq(0).text()\n      current_book.update_time = $(&#x27;#info p&#x27;).eq(2).text()\n      current_book.latest_chapter = $(&#x27;#info p&#x27;).eq(3).html()\n      current_book.intro = $(&#x27;#intro&#x27;).html()\n      current_book.chapters = [];\n\n      for(var i = 0; i&lt; urls.length; i++){\n        var url = urls[i]\n        \n        var _url = $(url).attr(&#x27;href&#x27;)+&quot;&quot;;\n        var num = _url.replace(&#x27;.html&#x27;,&#x27;&#x27;);\n        var title = $(url).text();\n\n\n        current_book.chapters.push({\n          num: num,\n          title: title,\n          url: _url\n        })\n      }\n      \n      console.log(current_book)\n    }\n});\n\nc.queue(&#x27;http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;&#x27;);\n<\/code><\/pre><p>这里主要是拿jQuery解析dom。然后赋值current_book<\/p>\n<p>执行<\/p>\n<pre class=\"prettyprint\"><code>node examples&#x2F;1&#x2F;chaper-list.js\n{ title: &#x27;大主宰&#x27;,\n  author: &#x27;作    者：天蚕土豆&#x27;,\n  update_time: &#x27;更新时间：2016-07-10&#x27;,\n  latest_chapter: &#x27;最新章节：&lt;a href=&quot;4091426.html&quot; target=&quot;_blank&quot;&gt;第一千两百六十二章 大陆洗礼&lt;&#x2F;a&gt;&#x27;,\n  intro: &#x27;\\n\\t\\t\\t\\t\\t&lt;p&gt;    大千世界，位面交汇，万族林立，群雄荟萃，一位位来自下位面的天之至尊，在这无尽世界，演绎着令人向往的传奇，追求着那主宰之路。\\n    无尽火域，炎帝执掌，万火焚苍穹。\\n    武境之内，武祖之威，震慑乾坤。\\n    西天之殿，百战之皇，战威无可敌。\\n    北荒之丘，万墓之地，不死之主镇天地。\\n    ......\\n    少年自北灵境而出，骑九幽冥雀，闯向了那精彩绝伦的纷纭世界，主宰之路，谁主沉浮？\\n    大千世界，万道争锋，吾为大主宰。\\n    ..................\\n&lt;&#x2F;p&gt;\\n\\t\\t\\t\\t\\t&lt;p&gt;各位书友要是觉得《大主宰》还不错的话请不要忘记向您QQ群和微博里的朋友推荐哦！&lt;&#x2F;p&gt;\\n\\t\\t\\t\\t&#x27;,\n  chapters: \n   [ { num: &#x27;153064&#x27;, title: &#x27;第一章已发。&#x27;, url: &#x27;153064.html&#x27; },\n     { num: &#x27;153065&#x27;, title: &#x27;第一章 北灵院&#x27;, url: &#x27;153065.html&#x27; },\n     { num: &#x27;153066&#x27;, title: &#x27;第二章 被踢出灵路的少年&#x27;, url: &#x27;153066.html&#x27; },\n     { num: &#x27;153067&#x27;, title: &#x27;第三章 牧域&#x27;, url: &#x27;153067.html&#x27; },\n     { num: &#x27;153068&#x27;, title: &#x27;第四章 大浮屠诀&#x27;, url: &#x27;153068.html&#x27; },\n<\/code><\/pre><p>想要的信息都准备好了，下面就开始爬某一章吧<\/p>\n<h2>爬取某一章<\/h2>\n<p>看一下<\/p>\n<pre class=\"prettyprint\"><code>第一章 北灵院\nhttp:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;153065.html\n<\/code><\/pre><p>和之前的地址的差别是什么呢？<\/p>\n<ul>\n<li><a href=\"http://www.biquku.com/0/330\">http://www.biquku.com/0/330<\/a> 是一样的<\/li>\n<li>153065.html章节地址<\/li>\n<\/ul>\n<p>再回顾一下<\/p>\n<pre class=\"prettyprint\"><code>  chapters: \n   [ { num: &#x27;153064&#x27;, title: &#x27;第一章已发。&#x27;, url: &#x27;153064.html&#x27; },\n<\/code><\/pre><p>也就是说 url 即是章节地址，剩下的就拼接起来就好了。<\/p>\n<pre class=\"prettyprint\"><code>function one(chapter){\n  console.log(chapter)\n  c.queue([{\n    uri: &#x27;http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;&#x27; + chapter.num + &#x27;.html&#x27;,\n    jQuery: jsdom,\n    forceUTF8:true,\n    &#x2F;&#x2F; The global callback won&#x27;t be called\n    callback: function (error, result, $) {\n        var content = $(&#x27;#content&#x27;).html();\n        console.log(content)\n    }\n  }]);\n}\n<\/code><\/pre><p>模拟执行代码<\/p>\n<pre class=\"prettyprint\"><code>var chapter = { num: &#x27;4063307&#x27;, title: &#x27;第一千两百五十二章 现世！&#x27;, url: &#x27;4063307.html&#x27; }\n\none(chapter);\n<\/code><\/pre><p>执行<\/p>\n<pre class=\"prettyprint\"><code>node examples&#x2F;1&#x2F;chaper-one.js\n{ num: &#x27;4063307&#x27;, title: &#x27;第一千两百五十二章 现世！&#x27;, url: &#x27;4063307.html&#x27; }\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一千两百五十二章&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;轰轰！&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;灵战子的低吼声，犹如雷鸣一般在这天地之间回荡，一股股磅礴浩瀚的灵力，也是犹如洪流一般，不断的从其体内呼啸而出，引得空间震荡。◇↓，&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此时的灵战子，双目精光涌动，神采飞扬，再没了先前的那种虚弱之感，显然，借助着那所谓的\u201c战祭\u201d，他直接是在顷刻间就将自身状态恢复到了巅峰。&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前消耗的灵力，也是再度充盈了他的身躯。\n<\/code><\/pre><h2>总结<\/h2>\n<p>爬取一本书的流程<\/p>\n<ul>\n<li>先取列表<\/li>\n<li>再去章节<\/li>\n<\/ul>\n<p>技能<\/p>\n<ul>\n<li>node-crawler 爬取，发送http请求，是基于request模块的<\/li>\n<li>结合jsdom，使用类似于jquery的dom操作，解析结果<\/li>\n<\/ul>\n<p>node-crawler有2种用法<\/p>\n<ul>\n<li>c.queue方法如无callback，走全局的callback，这是获取列表的时候的用法<\/li>\n<li>c.queue方法如有callback，走自己的callback，这是获取章节的用法<\/li>\n<\/ul>\n<p>我们的做法<\/p>\n<ul>\n<li>最小化问题，先关注爬取一本书的流程<\/li>\n<li>爬取一本书的流程中的列表<\/li>\n<li>爬取一本书的流程中的章节<\/li>\n<\/ul>\n<p>在这个过程中，我们可以很好的学习node-crawler和jquery的dom操作，知识点整体来说比较少，更加容易学习。<\/p>\n<p>下面，爬取的信息咋办呢？见下一章。<\/p>\n<h2>更多<\/h2>\n<p>参见 <a href=\"https://github.com/i5ting/githubrank\">https://github.com/i5ting/githubrank<\/a><\/p>\n<p>全文完<\/p>\n<p>欢迎关注我的公众号【node全栈】<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FtALxsauUkYDGdzcuA5y6BaIdUMC\" alt=\"node全栈.png\"><\/p>\n<\/div>","title":"Node.js写爬虫系列","last_reply_at":"2016-09-10T01:55:24.817Z","good":true,"top":false,"reply_count":34,"visit_count":3102,"create_at":"2016-08-30T06:38:07.475Z","author":{"loginname":"i5ting","avatar_url":"https://avatars.githubusercontent.com/u/3118295?v=3&s=120"}},{"id":"57cd6e3d6dac8a4a47ab2098","author_id":"57cd6dbc8624502e4751354e","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>受邀写一篇 Mobi.css 的诞生历程，请原谅我吸引眼球的标题，我会努力把这篇文章写得有一些干货的。<\/p>\n<\/blockquote>\n<p><a href=\"http://github.com/xcatliu/mobi.css\">GitHub Repo<\/a> | <a href=\"http://getmobicss.com\">Homepage<\/a> | <a href=\"https://news.ycombinator.com/item?id=12421804\">Hacker News 上的讨论<\/a><\/p>\n<p>提要：<\/p>\n<blockquote>\n<p>Mobi.css 是一个轻量、灵活的移动端 CSS 框架。发布一周以来，获得了 600+ stars，登上了 GitHub Trending Top1（CSS），在 Hacker News 上进入了前三。<\/p>\n<p>这篇文章会先介绍一下创造 Mobi.css 的思路，再介绍一下我在推广 Mobi.css 中的心得。<\/p>\n<\/blockquote>\n<h2>为什么要创造 Mobi.css<\/h2>\n<p>当我在设计一个新的 Focus on 移动端用户的网站（比如面向微信用户的网站）的时候，调研了一些现有的 CSS 框架，应用比较广泛的有 Bootstrap, Foundation, Pure.css, Framework7, Skeleton 等。<\/p>\n<p>他们都很优秀，但是都有一些缺点。<\/p>\n<ul>\n<li>Bootstrap: 太大太笨重了，对于桌面端用户我希望展示与手机端一样的页面，可能再加上一个二维码，将用户导向微信（类似于微信公众号的文章在网页中的样式）<\/li>\n<li>Foundation: 没有实践过，看上去也很大，大部分都是我不需要的功能<\/li>\n<li>Skeleton: 在移动端有一些 bug，<code>overflow:auto;<\/code> 的滑动不平滑，<code>&lt;select&gt;<\/code> 样式太丑，官网的 <code>&lt;pre&gt;&lt;code&gt;<\/code> 在 iPhone 里根本不 work，说明他们没有在手机上测试过<\/li>\n<li>Framework7: 适合做 WebApp，而我不太喜欢那种仿原生 App 的设计<\/li>\n<li>Pure.css: 很优秀，足够小巧，没什么特别的缺点，如果定制一下应该也可以满足需求。不过我还希望框架层面能够有一些针对移动端的设计<\/li>\n<\/ul>\n<p>于是我决定自己造一个轮子。<\/p>\n<p>造新轮子之前一定要做好调研，否则可能白费了功夫。<\/p>\n<h2>开发过程中的心得<\/h2>\n<h3>善用工具<\/h3>\n<p>CSS 框架相比于 JavaScript, React 等简单得多，但是也不能忽视了工具的使用。我选择了以下工具：<\/p>\n<ul>\n<li>Sass (scss)/Autoprefixer: CSS 预处理器都大同小异，Sass 功能比较全，所以选择了它。移动端也需要兼容不同设备，Autoprefixer 可以自动加上 <code>-webkit-<\/code> 等前缀<\/li>\n<li>Ejs/Marked/Highlight.js: 构建 website 的工具，一开始是手写 HTML，发现根本 hold 不住。这些工具后期可以用静态网站生成器替换<\/li>\n<li>Gulp: 构建工具，串起其他工具<\/li>\n<li>Travis CI/GitHub Pages/Coding Pages: 静态页面服务，一开始手动部署网站，后来发现太麻烦了，就用 Travis 自动部署了<\/li>\n<\/ul>\n<p>磨刀不误砍柴工，善用工具可以大大提高开发效率。<\/p>\n<h3>站在巨人的肩膀上<\/h3>\n<p>开源社区上的代码都是别人的积累，如果离开了它们，Mobi.css 很难在短时间内完成开发，我借鉴了以下开源项目：<\/p>\n<ul>\n<li>Normalize.css: 大部分 <code>_reset.scss<\/code> 部分是借鉴它的。没有直接引入它的原因是有少部分它的代码是不需要的<\/li>\n<li>Bootstrap v4: 使用最广泛的 CSS 框架，可借鉴的太多了<\/li>\n<li>Pure.css/Skeleton: 借鉴了手机上的样式<\/li>\n<li>微信公众号的 desktop 版: 借鉴了在 desktop 上的样式，以及中文字体<\/li>\n<li>以及很多其他框架<\/li>\n<\/ul>\n<h3>重视写文档<\/h3>\n<p>开源项目要受欢迎，文档是非常重要的。<code>README.md<\/code> 要让大家能在短时间内了解项目的特点。网站要能够尽可能输出自己的理念。<\/p>\n<p>如果可以的话，最好用英文（或者双语）写。否则只能有中国人来关注你的项目了。要知道，外国开发者比中国开发者多很多倍的。<\/p>\n<p>不要担心自己英语不好，只要表达的内容能让外国人看得懂即可。等项目成熟了，自然会有人帮你修改文档。<\/p>\n<h3>注意社区的一些规则<\/h3>\n<ul>\n<li>标明 License<\/li>\n<li>遵守版本号规则，不要乱做 Breaking changes<\/li>\n<\/ul>\n<h2>如何推广<\/h2>\n<p>不要觉得不好意思推广，我们推广不是功利性的求赞求关注（逃。<\/p>\n<p>而是因为没有人关注的项目，是不可能向好的方向发展的。而如果自己不做主动的推广，项目也很难被关注。<\/p>\n<p>推广这部分其实我并不是很擅长，这里只写出一些我自己的心得吧。<\/p>\n<h3>在对的时间发对的帖<\/h3>\n<p>一般在下班的时间，大家都会拿出手机刷一刷。这时你的贴最容易被曝光。等到人气上去了，晚上睡觉之前大家再刷一波手机，就有更多人看到了。<\/p>\n<p>发帖的时候只需要简要的说重点，引导用户到 GitHub 或你的网站。但是慎用「求 star」等字眼，功利性太强。<\/p>\n<h3>推广渠道<\/h3>\n<p>我用了以下推广渠道（按推广效果排序）：<\/p>\n<ul>\n<li>Hacker News<\/li>\n<li>V2EX<\/li>\n<li>开发者头条<\/li>\n<li>SegmentFault<\/li>\n<li>Hacpai<\/li>\n<li>Startup News<\/li>\n<li>光谷社区<\/li>\n<li>Reddit<\/li>\n<\/ul>\n<h3>聆听意见，及时反馈<\/h3>\n<p>自己的想法总归是一个人的，吸取了别人的建议才能让项目更好的发展。Mobi.css 就有一部分 API 是听取了别人的建议之后修改的。<\/p>\n<p>当然，自己需要有自己的判断。Mobi.css 的准则很简单：这个设计是不是 focus on mobile 的。<\/p>\n<h3>最重要的是，项目要有价值<\/h3>\n<p>没有价值的项目即使推广再多，也没有人会关注的，只会招来一顿猛喷。<\/p>\n<h2>总结<\/h2>\n<p>Mobi.css 在短时间内获得了很多关注，离不开大家的支持，离不开开源社区的帮助。<\/p>\n<p>我知道这只是 Mobi.css 项目的开始，后面有更长的路要走，感兴趣的可以一起来建设。<\/p>\n<p><a href=\"http://github.com/xcatliu/mobi.css\">GitHub Repo<\/a> | <a href=\"http://getmobicss.com\">Homepage<\/a> | <a href=\"https://news.ycombinator.com/item?id=12421804\">Hacker News 上的讨论<\/a><\/p>\n<\/div>","title":"7 天 600 stars， Mobi.css 是如何诞生的","last_reply_at":"2016-09-08T13:53:09.792Z","good":true,"top":false,"reply_count":22,"visit_count":1541,"create_at":"2016-09-05T13:08:13.290Z","author":{"loginname":"xcatliu","avatar_url":"https://avatars.githubusercontent.com/u/5453359?v=3&s=120"}},{"id":"558a80b0c31358754d3aa343","author_id":"501e84b0f767cc9a51c156e5","tab":"share","content":"<div class=\"markdown-text\"><p>近年来，由于 JavaScript 在服务端的兴起，使用 Node.js (以下简称 Node) 或 io.js 编写 Web 应用服务的初创团队和产品日益增多。由于 JavaScript 其天生的 Web 通用性设计，导致编写 Node 应用极易上手，开发效率高，但随着 Node 的火热发展，使用 Node 和其相关技术作为技术框架的应用，也存在不少 debug 与性能方面的问题。<\/p>\n<p>Node 由于其 libuv 多线程池模拟异步 IO 的设计，能够很高效的解决单位资源下高并发的业务场景，而为很多程序员所钟爱。但当我们编写完成 Node 应用，将之部署到生产环境后，经常会发现诸如「CPU占用率过高」或「不同应用实例间负载不均衡」之类的性能问题，这些问题有时出在单元模块的编码缺陷，比如某些 IO 的等待触发回调时间过长，或不同服务间的通信导致了较高的 IO 延迟，导致轮询事件堆积，引发性能问题；有时出在调用远程 API 请求的时间过长，或某项操作使用了阻塞主执行线程的技术方案而导致。<\/p>\n<p>这些性能问题，有时可以在单元测试或者压力测试中看出端倪，但更多时候，是随着生产环境服务的外部压力增大后，缓慢呈现出来的一种不确定性状态，加之 Node 应用的架构设计多采用  SOA，不同服务之间的通信状态存在不确定性，使得此种性能问题的排查存在相当的难度。<\/p>\n<p>实时应用性能检测需求的产生，加速了 Applicaiton Performance Management 平台的发展速度，在国外，我们可以使用 New Relic 来进行实时的应用性能检测，查看应用间通信的拓扑图，跟踪和预警不同业务层面的压力情况与负载，从而进行科学的资源调度和弹性服务部署。\n将线上业务的性能问题可视化，透明化，尽量在问题发生之前或将要发生时思考解决对策，这也是此类平台不同于一般的实时统计平台的一大特征之一。<\/p>\n<p>在这篇文章中，我们将要通过从 Node 应用的业务逻辑分析、部署 Node APM 探针实战这几个简单的步骤，理解如何对 Node 应用进行性能监测，找出问题，并优化程序的整个过程。<\/p>\n<p>让我们思考一种常用的 Web 应用业务逻辑。在这个 Web 应用中，用户请求某个资源列表，我们的服务通过查询不同的数据库或外部服务，在返回资源的同时记录用户的查询日志，在触发最大查询量之后警告用户，并在一段时间后自然释放\n继续正确返回用户所需的资源列表。在这个应用场景中，我们需要对数据库进行简单的读写操作，可能还涉及与其他服务的网络 IO，当然，在这个过程中，我们还需要对用户进行鉴权，可能需要进行哈希运算，并且将用户常用数据，如查询次数与 token 存放在\n更高效的内存数据库中，且对此类数据进行持久化操作。在这个案例中，我们不会实现所有业务逻辑的范例，但我们可以理解如何从性能分析角度去思考对于一个通用的 Web 业务，哪些关键点需要关注执行效率，哪些单元需要实时监测 IO 延迟。<\/p>\n<h2>搭建一个范例 Node 项目<\/h2>\n<p>在 Web 业务场景中，我们处理最多的逻辑是触发异步 IO，等待执行回调。有一种简单的方法可以将每次 IO 的时间可视化，就是为每个 callback 添加带有自动打印时间戳功能的 debug 标签（可以参考 npm 上的 <code>debug<\/code> 模块）但对于一个多实例，甚至分布式业务\n，此类记录日志的方法还涉及到本文不会讨论的日志集中分析与处理的相应逻辑。对于一个初创产品或团队，使用这样的方法可以很直观的可视化单元模块的请求与等待时间，但很难可视化一个项目或整个应用服务系统的性能数据，因此略有不足。<\/p>\n<p>我们可以使用 <code>Connect<\/code> 或 <code>Express<\/code> 快速搭建一个符合此场景的 Node 项目，为了节省时间，也为了更多地关注在业务逻辑上，在这里我们采用一个 Express 框架的包装，<code>express-scaffold<\/code> 来构建这个范例项目，为了节省编码，我们使用了部分 ES6 的写法书写范例代码：<\/p>\n<pre class=\"prettyprint language-js\"><code>import server from &#x27;express-scaffold&#x27;\n\n&#x2F;&#x2F; 创建一个服务实例\nnew server({\n  name: &#x27;My very first App&#x27;,\n  database: {\n    name: &#x27;appdb&#x27;\n  }\n})\n&#x2F;&#x2F; 创建数据表\n.models((db, Schema) =&gt; {\n  const userModel = new Schema({\n    name: String,\n    created: Date,\n  })\n  \n  return {\n    user: db.model(&#x27;user&#x27;, userModel)\n  }\n})\n&#x2F;&#x2F; 抽象控制器\n.ctrlers((models, Ctrler) =&gt; {\n  return {\n    user: new Ctrler(models.user)\n  }\n})\n.routes((app, ctrlers) =&gt; {\n  console.log(&#96;${ app.locals.site.name } is running&#96;)\n  \n  &#x2F;&#x2F; 范例路由\n  app.get(&#x27;&#x2F;&#x27;, (req, res, next) =&gt; res.send(&#x27;ok&#x27;))\n  \n  &#x2F;&#x2F; 查询数据表的范例路由\n  app.get(&#x27;&#x2F;users&#x27;, (req, res, next) =&gt; {\n\t \tvar query = req.query \n\t\n    ctrlers.user.find(query, function(err, users) {\n      if (err) \n\t\t  \treturn next(err)\n\t  \n      res.json(users)\n    })\n  })\n})\n.run();\n<\/code><\/pre><p>以上代码基于 MongoDB 和 Express 模块搭建了一个简单的 MVC 项目，在 app 实例中，我们可以使用注入的相关依赖，比如控制器，来操作对数据库的读写。在接下来的代码中，我们会主要关注在路由的设计和相关的业务逻辑上。<\/p>\n<p>一个简单的例子是，当我们需要对用户的请求进行鉴权，可能涉及到一些哈希计算，和获取文件中的读写操作。<\/p>\n<pre class=\"prettyprint language-js\"><code>app.get(&#x27;&#x2F;resources&#x2F;:type&#x27;, (req, res, next) =&gt; {\n  if (!req.query.token)\n    return next(new Error(&#x27;token required&#x27;))\n  \n  &#x2F;&#x2F; 通过计算鉴权\n  if (!checkHash(req.query.token, configs.get(&#x27;token&#x27;)))\n    return next(new Error(&#x27;token invalid&#x27;)\n  \n  try {  \n    const data = fs.readFilySync(&#96;resources-${ req.params.type }&#96;)\n    return res.send(data)\n  } catch (err) {\n    return next(err)\n  }\n})\n<\/code><\/pre><p>在这段代码中可能存在两个性能问题，如果我们不对这些问题进行实时跟踪，单凭单元测试中反馈的计算和 IO 延时，我们可能无法对整个应用的性能做出可靠的评测。通常来说，Node 应用程序虽然会有诸多 <code>child_process<\/code> 实例，但无论对于哪个实例，其 JavaScript 执行线程，也就是主线程都不应当进行太多同步计算操作。从某种意义上来说，JavaScript 可能并不擅长进行同步计算。在这里，我们可能会很容易忽视一个 hash 计算带来的延时，所以，我们可以为这个计算先后加上 debug 标签，但更好的监控方式，我们会在下面的范例中提到。<\/p>\n<p>另外一个问题在于，文件 API 的同步读写操作很可能会带来额外的风险，因此，最好的方式就是，不在任何 Node 项目中使用同步 API 来处理数据，以免产生难以定位的由多种因素导致的性能问题。<\/p>\n<h2>植入听云 Node 探针<\/h2>\n<p><img src=\"http://ww3.sinaimg.cn/large/61ff0de3gw1etfc1g2xfej20o907wgmm.jpg\" alt><\/p>\n<p>对于 Node 应用服务，APM 探针是如何在系统中运作，从而保证了对几乎每个层面的 IO 都能监控并且不干扰正常的业务逻辑呢？这也是我一直以来比较好奇的一个问题。在这篇文章里，我们使用国内比较有名的 APM 服务之一，听云的 Node 探针来研究，如何通过一个不影响业务的探针模块，来实现对基于所有 IO 的跟踪和实时监测。<\/p>\n<p>简单来说，听云 Node 探针是以 require hook 的方式，在服务的启动脚本上初始化，通过挂载在 module load 事件的方式对大多数发起网络 IO 的库进行包装，从而能够在服务的各个层面监测到应用的网络 IO 延时，以及应用宿主机上的 CPU 负载，内存占用情况等相应的系统数据。<\/p>\n<p>为了研究探针的工作原理，理解为什么探针可以有效的监测上述常用耗时的计算过程或异步 IO，我们先需要下载探针模块。<\/p>\n<h3>新建听云账户，获取 License Key，并下载 Node 探针<\/h3>\n<p><img src=\"http://ww2.sinaimg.cn/large/61ff0de3gw1etfc1yqw5yj20sn06q3z1.jpg\" alt><\/p>\n<p>首先，我们需要在听云官网上注册一个可用的账户。在新建应用界面中，我们可以得到一个 License Key，同时，下载听云 Node 探针的压缩包文件，解压这个压缩包文件之后，就能看到听云 Node 探针的目录结构。实际上，这个探针是一个 Node module。接下来，在需要进行配置的项目目录中，执行指令 <code>npm install tingyun-agent-nodejs-latest.tar.gz<\/code> 就可以将这个压缩包作为一个 Node 模块解压并安装到 <code>node_modules<\/code> 文件夹中，并安装相应的依赖模块，以供 require 调用。<\/p>\n<p><img src=\"http://ww2.sinaimg.cn/large/61ff0de3gw1etfc2ppp8cj20mb0he0tn.jpg\" alt><\/p>\n<h3>修改 Node 探针配置文件<\/h3>\n<p>在同目录执行指令 <code>cp node_modules/tingyun/tingyun.js ./<\/code> 以便将听云 Node 探针中的 <code>tingyun.js<\/code> 也就是探针配置文件复制到项目目录中。我们打开这个探针配置文件，可以看到：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 听云代理用户配置项\nexports.config = {\n  &#x2F;&#x2F; 应用名\n  app_name : [&#x27;nodetest&#x27;],\n  &#x2F;&#x2F; 授权序号\n  licenseKey : &#x27;1231232132131&#x27;,\n  &#x2F;&#x2F; 日志级别\n  &#x2F;&#x2F; debug&quot; &gt; &quot;verbose&quot; &gt; &quot;info&quot; &gt; &quot;warning&quot; &gt; &quot;error&quot; &gt; &quot;critical&quot;\n  agent_log_level : &#x27;info&#x27;\n};\n<\/code><\/pre><p>探针配置文件非常简单，只需要配置之前得到的 License Key 并输入正确的 app 名称，即可完成配置。<\/p>\n<h3>添加 require hook，重启应用<\/h3>\n<p>最后一步，也是最重要的一步配置操作，就是将听云 Node 探针 require 到 Node 服务的启动文件当中，以便于听云 Node 探针对相应的 IO 库进行包装。在 Node 服务的启动脚本最上方添加:<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 首先植入探针\nrequire(&#x27;tingyun&#x27;)\n&#x2F;&#x2F; 处理剩余应用初始化与启动逻辑 ...\n<\/code><\/pre><p>即可完成全部的探针配置，此时重启服务，几分钟后，就可在听云的管理面板上看到探针上传的实时性能监测日志。<\/p>\n<p><img src=\"http://ww4.sinaimg.cn/large/61ff0de3gw1etfc4eyp8jj211z0kjag3.jpg\" alt><\/p>\n<p>上图即为我们的范例程序执行几分钟后得到的综合图表结果，可以看出，听云探针除了可以分析出应用程序的总体相应时间和阻塞延迟，还支持细分显示出 NoSql 数据库如 MongoDB 的响应时间，同时可以在 dashboard 中的最耗时Web应用过程（Web Action）图表看出具体路由的响应时间差别。当然，除此之外，也能监测常规的宿主机内存和 CPU 占用情况。<\/p>\n<p>如果我们打开性能拓扑视图，可以更清楚的看清应用程序实例与数据库间 IO 延迟情况，在这个简单的范例中，我们只连接一个 MongoDB 实例进行查询，所以整个项目的拓扑图清晰可辨<\/p>\n<p><img src=\"http://ww4.sinaimg.cn/large/61ff0de3gw1etfc5fdaxmj20un0aeq3r.jpg\" alt><\/p>\n<p>对大部分程序来说，性能瓶颈主要归结为数据库 IO 延迟过高，NoSQL 性能分析功能则可以将这个拓扑图放大，着重分析后端数据库的耗时查询具体对应何种查询条件，在这个简单的项目中，我们可以看到如下的 NoSQL 总耗时结果分析<\/p>\n<p><img src=\"http://ww2.sinaimg.cn/large/61ff0de3gw1etfc6mqcn3j211t0e10v7.jpg\" alt>\n<img src=\"http://ww2.sinaimg.cn/large/61ff0de3gw1etfc6wswczj20pa0jhjts.jpg\" alt><\/p>\n<p>不过，为什么通过简单的探针模块，可以得出这种通用性的分析结果呢？我们不妨仔细研究一下听云的这个探针模块是如何运作的。\u200b<\/p>\n<h2>听云 Node 探针分析<\/h2>\n<p>上述简单的植入教程已经大致提到，听云 Node 探针是如何在项目文件中挂载的。如果我们仔细研究听云 Node 探针的代码结构，可以看到 <code>parsers<\/code> 文件夹中列出了所有支持的包装，包括 Node 核心组件 <code>http<\/code>，和我们常用的两个 Web frame: <code>Connect<\/code> 与 <code>Express<\/code>，同样地，它也支持跟踪 <code>MySQL<\/code>, <code>Mongodb<\/code>, <code>Redis<\/code> 甚至最近非常活跃的数据库 <code>Cassandra<\/code>。<\/p>\n<p><img src=\"http://ww3.sinaimg.cn/large/61ff0de3gw1etfc7oiv9pj205m09sgm2.jpg\" alt><\/p>\n<p>植入探针的过程，实际上是 require 听云探针模块的触发的操作，在 require(\u2018tingyun\u2019) 被执行之后，探针目录下的 index.js 入口文件进行探针初始化，在这个过程中，对应配置文件被读取后，探针新建了一个 agent 实例对象，并使用 shimmer 函数库完成了相关初始化操作，其中，shimmer.patchModule 操作将会对 IO 库进行包装:<\/p>\n<pre class=\"prettyprint language-js\"><code>patchModule : function patchModule(agent) {\n  logger.debug(&quot;Wrapping module loader.&quot;);\n  var Module = require(&#x27;module&#x27;);\n\n  shimmer.wrapMethod(Module, &#x27;Module&#x27;, &#x27;_load&#x27;, function cb_wrapMethod(load) {\n    return function cls_wrapMethod(file) {\n      return _postLoad(agent, load.apply(this, arguments), file);\n    };\n  });\n}\n<\/code><\/pre><p>在这个函数中，require(\u2018module\u2019) 一段引入了 Node 的模块系统库，module 模块，实现了 Node 中所有对模块的定义，引入，输出的相关操作，听云探针通过对 module 模块的包装，也就是 shimmer.wrapMethod 函数，当任何模块加载事件触发时，触发相应的跟踪回调。让我们仔细阅读 wrapMethod 函数与回调函数 _postLoad 的实现：<\/p>\n<pre class=\"prettyprint language-js\"><code>wrapMethod : function wrapMethod(nodule, noduleName, methods, wrapper) {\n  if (!methods) return;\n  if (!noduleName) noduleName = &#x27;[unknown]&#x27;;\n  if (!Array.isArray(methods)) methods = [methods];\n\n  methods.forEach(function cb_forEach(method) {\n    var method_name = noduleName + &#x27;.&#x27; + method;\n\n    if (!nodule) return;\n    if (!wrapper) return logger.verbose(&quot;Can&#x27;t wrap %s, no wrapper.&quot;, method_name);\n    var original = nodule[method];\n\n    if (!original) return logger.debug(&quot;%s not defined, skip wrapping.&quot;, method_name);\n    if (original.__TY_unwrap) return logger.verbose(&quot;%s already wrapped.&quot;, method_name);\n\n    var wrapped = wrapper(original);\n    wrapped.__TY_original = original;\n    wrapped.__TY_unwrap = function __TY_unwrap() {\n      nodule[method] = original;\n      logger.debug(&quot;Removed instrumentation from %s.&quot;, method_name);\n    };\n\n    nodule[method] = wrapped;\n    if (shimmer.debug) instrumented.push(wrapped);\n  });\n}\n<\/code><\/pre><p>通过阅读 wrapMethod 函数的实现可以看到，在 <code>shimmer.wrapMethod<\/code> 中回调函数包装中的 <code>load<\/code> 函数，在这里，就是 <code>require('module')._load()<\/code> 方法。而通过包装后返回的函数 <code>cls_wrapMethod<\/code>，在后续的代码中，又会替换掉 <code>require('module')._load()<\/code>，读到这里，我们就能大概理解探针是如何不影响业务逻辑而得以跟踪所有模块的原因。<\/p>\n<pre class=\"prettyprint language-js\"><code>function _postLoad(agent, nodule, name) {\n  var base = path.basename(name);\n  var wrapper_module = (name === &#x27;pg.js&#x27;) ? &#x27;pg&#x27;: base;\n  \n  if (WRAPPERS.indexOf(wrapper_module) !== -1) {\n    logger.debug(&#x27;wrap %s.&#x27;, base);\n    var filename = path.join(__dirname, &#x27;..&#x2F;parsers&#x2F;wrappers&#x27;, wrapper_module + &#x27;.js&#x27;);\n    instrument(agent, base, filename, nodule);\n  }\n  \n  return nodule;\n}\n<\/code><\/pre><p>在 <code>_postLoad<\/code> 函数中，我们可以看到，听过对当前初始化的模块的判断，听云 Node 探针会所有在 <code>WRAPPERS<\/code> 数组中的模块都进行了包装，相关的包装应当定义了对应的回调函数，并执行了 <code>instrument<\/code> 函数，这个函数实际上是起到了 <code>require<\/code> 包装模块的作用，而这部分包装是放置在 <code>../parsers/wrappers<\/code> 文件夹中，以模块名作为索引区分。我们查看这个文件中的 <code>WRAPPERS<\/code> 数组，可以看到听云 Node 探针目前已经支持以下几个模块的实时性能跟踪：<\/p>\n<pre class=\"prettyprint language-js\"><code>var WRAPPERS = [\n  &#x27;connect&#x27;,\n  &#x27;express&#x27;,\n  &#x27;generic-pool&#x27;,\n  &#x27;hapi&#x27;,\n  &#x27;memcached&#x27;,\n  &#x27;mongodb&#x27;,\n  &#x27;mysql&#x27;,\n  &#x27;node-cassandra-cql&#x27;,\n  &#x27;pg&#x27;,\n  &#x27;redis&#x27;,\n  &#x27;restify&#x27;,\n  &#x27;thrift&#x27;\n];\n<\/code><\/pre><p>跟踪到这里，我们已经能理解听云 Node 探针的大致工作原理，剩下的事情，就交给各位感兴趣的读者，以 Express 为例，仔细阅读 <code>../parsers/wrappers/express.js<\/code> 中类似 wrapRender、wrapMatchRequest 的实现，以及探针是如何使用 shimmer 模块对 Express 中的具体函数方法进行重复包装的过程，如果你对 Node 实时性能监测感兴趣，不妨也可以模仿这里的实现，自己写一个探针模块喔~<\/p>\n<\/div>","title":"聊聊实时 Node 应用性能监测的实现","last_reply_at":"2016-09-07T05:40:04.466Z","good":true,"top":false,"reply_count":11,"visit_count":5327,"create_at":"2015-06-24T10:04:32.050Z","author":{"loginname":"turing","avatar_url":"//gravatar.com/avatar/fd05a307dcd03fdef795a3c9810ae667?size=48"}},{"id":"56a3c8f47ec020ed4b96b2cd","author_id":"556d9f40bf871b3962efb841","tab":"share","content":"<div class=\"markdown-text\"><p>本篇文章翻译自expressjs官方网站，源地址如下：<a href=\"http://expressjs.com/en/advanced/best-practice-performance.html\">express最佳实践<\/a> ,分别从dev角度和ops角度讨论了如何提升express应用的运行性能以及部署的最佳方式。<\/p>\n<p>欢迎访问<a href=\"http://jsmean.com/blog/post/56a3b2947b7d4ff930cc7475\">个人blog<\/a>查看本文内容。<\/p>\n<h3>针对开发者需要注意的问题<\/h3>\n<p>对于一个express应用我们，一般有以下的几种方法来提升应用的运行效率以及响应率。<\/p>\n<ol>\n<li>使用gzip压缩<\/li>\n<li>代码中不要使用同步函数<\/li>\n<li>使用中间件处理静态文件<\/li>\n<li>合理的日志处理方法<\/li>\n<li>正确的处理异常<\/li>\n<\/ol>\n<p>以下我们将分别对于每个子项目进行展开分析。<\/p>\n<h5>1.使用gzip压缩<\/h5>\n<p>使用gzip压缩可以显著的减小响应包的大小，这样就提升了客户端的响应速度，我们可以通过使用compression中间件来处理gzip的压缩。对于一个大量用户的网站，最佳的方式是在反向代理端设置压缩方式。可以参考我的另一篇文章专门介绍如何配置nginx来处理压缩和静态文件的。这样的话，我们在代码端就不用再调用compression中间件了，nginx会帮助我们完成此项工作。<\/p>\n<pre class=\"prettyprint\"><code>var compression = require(&#x27;compression&#x27;);\nvar express = require(&#x27;express&#x27;);\nvar app = express();\napp.use(compression());\n<\/code><\/pre><h5>2.不要使用同步函数<\/h5>\n<p>我们知道node主进程为一个单一线程的程序(异步处理为多线程)。主线程中如果我们调用一些同步函数，而且这些同步函数执行时间较长，则会影响后续程序的执行等待时间。针对web端则表现为其他用户的访问延迟增大。所以在生产环境中，即便一个返回几个微妙的程序，对于大量用户的访问都将会造成积累效应。所以尽量使用异步的方式去编写代码。<\/p>\n<p>如果使用Node.js 4.0+ 或者 io.js 2.1.0+,可以使用参数 --trace-sync-io 去打印针对同步函数的告警信息。<\/p>\n<h5>3.使用中间件来处理静态文件<\/h5>\n<p>我们有时候调用res.sendFile()来处理静态文件，但是不要在生产环境中使用，这样会针对每个请求都去读该文件，不仅没有效率而且影响整体的性能，可以通过使用serve-static中间件来处理文件，但是我们推荐的更好的方式是使用nginx等反向代理静态文件。<\/p>\n<h5>4.合理的日志处理方式<\/h5>\n<p>我们在开发环境中有时候会通过console.log或者console.err标记一些点或者调试输出内容.但是这些函数都是同步的，将输出内容输出到终端与输出到文件的道理是相同，所以在生产环境中不要这样做。除非不得已去讲输出传递到另一个程序中的时候。我们可以使用debug模块来实现输出，该模块将判断环境变量是否是开发环境，执行debug输出，保证你的程序的异步处理。对于记录日志的话，大家可以参考一篇针对日志系统的比较文章<a href=\"https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/?_ga=1.264536015.1196661681.1453521338\">比较Winston和Bunyan<\/a>。<\/p>\n<h5>5. 正确的处理异常<\/h5>\n<p>首先对于node程序来说，一旦遇到不可处理的异常，则整个进程就会down掉，如果我们配置了pm2或者forever这样的进程管理工具的话，他会帮助我们去处理我们的程序失败自启动。<\/p>\n<p>对于代码中异常的处理我们一般的使用方法：<\/p>\n<ol>\n<li>使用try-catch<\/li>\n<li>使用<a href=\"http://expressjs.com/en/advanced/best-practice-performance.html#promises\">promises<\/a><\/li>\n<\/ol>\n<p>这里有一篇文章比较详细的介绍了如何构建健壮的程序来处理错误异常，供参考<a href=\"https://strongloop.com/strongblog/robust-node-applications-error-handling/?_ga=1.24936442.1196661681.1453521338\">链接地址<\/a><\/p>\n<p>不要使用uncaughtException来处理所有的异常，虽然一定程度上可以导致你的程序不中断，但是程序将包含不稳定的代码持续的运行下去，这样的代码运行在线上可能造成的后果更加的严重，甚至有过建议将该错误处理方式移除node内核。<\/p>\n<p>也不要使用domains来处理错误，该模块已被标记为待移除模块。<\/p>\n<p>使用try-catch是一种比较简单的错误处理方式，比如下面的代码：<\/p>\n<pre class=\"prettyprint\"><code>app.get(&#x27;&#x2F;search&#x27;, function (req, res) {\n &#x2F;&#x2F; Simulating async operation\n setImmediate(function () {\n   var jsonStr = req.query.params;\n   try {\n     var jsonObj = JSON.parse(jsonStr);\n     res.send(&#x27;Success&#x27;);\n   } catch (e) {\n     res.status(400).send(&#x27;Invalid JSON string&#x27;);\n   }\n });\n});\n<\/code><\/pre><p>但是我们知道try-catch只能应用在同步的代码上面，对于异步的代码处理我们无法使用该方式进行处理。对于异步代码的异常处理我们可以使用promises来完成。只需要增加一个catch()方法就可以捕获流程中的整个代码块的异常。<\/p>\n<pre class=\"prettyprint\"><code>app.get(&#x27;&#x2F;&#x27;, function (req, res, next) {\n  &#x2F;&#x2F; do some sync stuff\n  queryDb()\n    .then(function (data) {\n      &#x2F;&#x2F; handle data\n      return makeCsv(data)\n    })\n    .then(function (csv) {\n      &#x2F;&#x2F; handle csv\n    })\n    .catch(next);\n});\n\napp.use(function (err, req, res, next) {\n  &#x2F;&#x2F; handle error\n});\n<\/code><\/pre><p>当然了，我们需要在每个代码块中都加入promises返回。更多的信息可以参考一下链接<a href=\"https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/?_ga=1.235763905.1196661681.1453521338\">Asynchronous Error Handling in Express with Promises, Generators and ES7<\/a>。<\/p>\n<h3>生产环境安装部署<\/h3>\n<p>以下我们讨论的是针对生产环境中express应用安装部署上需要注意的问题。<\/p>\n<ol>\n<li>设置NODE_ENV为\u201cproduction\u201d<\/li>\n<li>确保应用的自动重启<\/li>\n<li>将应用部署一个集群中<\/li>\n<li>缓存请求结果<\/li>\n<li>使用负载均衡<\/li>\n<li>使用反向代理<\/li>\n<\/ol>\n<h5>1. 设置运行环境变量<\/h5>\n<p>一般我们设置node环境变量有两种，分别是 development 和 production。设置环境变量为production将会使得express应用<\/p>\n<ol>\n<li>缓存视图模板<\/li>\n<li>缓存css文件<\/li>\n<li>生成更少的冗余错误信息<\/li>\n<\/ol>\n<p>另外如果大家感兴趣的话可以查看这篇文章<a href=\"http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/\">环境变量测试<\/a>，这里作者对于设置该变量前后做了一些性能上的对比，非常详细。<\/p>\n<p>如果我们使用upstart来管理应用的话我们需要配置文件中加入环境变量<\/p>\n<pre class=\"prettyprint\"><code># &#x2F;etc&#x2F;init&#x2F;env.conf\nenv NODE_ENV=production\n<\/code><\/pre><p>如果是使用systemd来管理的话，则修改配置文件如下：<\/p>\n<pre class=\"prettyprint\"><code># &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;myservice.service\nEnvironment=NODE_ENV=production\n<\/code><\/pre><h5>2.确保自启动<\/h5>\n<p>这里自启动不仅仅指的是如何在程序异常终止之后启动而且还要保证程序在操作系统重启之后能自启动。这里我们分别介绍下两种情况。<\/p>\n<ol>\n<li>使用一个进程管理器<\/li>\n<\/ol>\n<p>进程管理器一般可以帮助我们，获得进程的运行性能和资源的消耗，动态的修改配置提升性能，集群控制。这里我么推荐的一般可以使用strongloop process manager或者pm2还有forever，同样详细的参考如下链接<a href=\"http://strong-pm.io/compare/?_ga=1.20403576.1196661681.1453521338\">进程管理器比较<\/a>\n通过上述的比较我们可以看出，strongloop的进程管理器支持的特性更丰富一些，特别是查看cpu占用堆占用，集成操作系统脚本，远程管理集群等等。<\/p>\n<ol>\n<li>随系统启动的程序自启动<\/li>\n<\/ol>\n<p>随系统启动的程序，我们可以使用之前的进程管理器，forever应该是不支持的。其他的都可以生成对应的启动脚本，当操作系统启动的时候，进程管理器启动，并带动程序的启动。或者我们可以直接配置使用systemd等方式来管理进程的开机启动。\n我们这里简单的通过介绍systemd的方式来介绍如何设置程序的随系统启动。systemd是一个linux系统的服务管理器。一个systemd的配置文件被称作为unit file.以.service为后缀。<\/p>\n<pre class=\"prettyprint\"><code>[Unit]\nDescription=Awesome Express App\n\n[Service]\nType=simple\nExecStart=&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;projects&#x2F;myapp&#x2F;index.js\nWorkingDirectory=&#x2F;projects&#x2F;myapp\n\nUser=nobody\nGroup=nogroup\n\n# Environment variables:\nEnvironment=NODE_ENV=production\n\n# Allow many incoming connections\nLimitNOFILE=infinity\n\n# Allow core dumps for debugging\nLimitCORE=infinity\n\nStandardInput=null\nStandardOutput=syslog\nStandardError=syslog\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n<\/code><\/pre><h5>3. 将app运行在一个集群中<\/h5>\n<p>在多核心处理上运行的应用，可以通过使用cluster模块启动多个实例运行在不同的处理器上。并在多个实例上实现\u201c负载均衡\u201d。\n<img src=\"http://expressjs.com/images/clustering.png\" alt=\"image\">\n但是对于不同的实例，由于内存空间的隔离，导致所有的程序对象都是本地的，无法实现共享，但是我们可以借助于redis这样的工具实现对象的共享。并且对于某个进程的终端不会影响其他进程的处理，只需要在编写代码的时候记录此次终端并生成一个新的实例即可。<\/p>\n<p>我们可以使用node的cluster模块（需要编写代码实现）或者是strongloop的进程管理器来处理，并且不需要修改代码。strongloop PM将根据cpu的数目自动的生成多个进程，并且可以手动调整该值。<\/p>\n<h5>4. 缓存请求<\/h5>\n<p>使用缓存，可以极大的提升响应速度，而不需要对于重复的请求做重复的操作。我们可以使用nginx<a href=\"https://serversforhackers.com/nginx-caching/\">缓存配置<\/a>来配置缓存<\/p>\n<h5>5. 使用负载均衡<\/h5>\n<p>单一的express进程服务，不管如何优化都无法达到一个很高的性能需求，特别是对于一个拥有很多用户的web应用。我们可以通过使用一个负载均衡器来完成应用的水平的扩展。比如使用nginx或者HAProxy来完成负载均衡。在使用负载均衡的时候，我们可能需要确保每一个请求关联相对应的会话ID落到同一个进程上。这里有一篇文章可以供参考，了解如何配置负载均衡<a href=\"http://socket.io/docs/using-multiple-nodes/\">socket.io配置负载均衡<\/a><\/p>\n<p>另外strongloop pm可以很好的与nginx配合设置负载均衡。<\/p>\n<h5>6. 反向代理服务<\/h5>\n<p>反向代理服务器一般设置在请求入口处，完成错误页面处理，压缩处理，缓存和静态文件处理，负载均衡操作等等。具体的可参考nginx或者HAProxy的配置来完成反向代理服务的搭建。<\/p>\n<p>PS: 个人网站 <a href=\"http://www.jsmean.com\">www.jsmean.com<\/a> 。基于mean stack 开发。主要是讨论一些js相关内容，欢迎大家访问<\/p>\n<\/div>","title":"Express 开发与部署最佳实践","last_reply_at":"2016-09-05T06:03:18.229Z","good":true,"top":false,"reply_count":55,"visit_count":8126,"create_at":"2016-01-23T18:39:48.809Z","author":{"loginname":"zhangmingkai4315","avatar_url":"https://avatars.githubusercontent.com/u/8868334?v=3&s=120"}}]
     */

    private boolean success;
    /**
     * id : 575d28576121c03a6e955f19
     * author_id : 50725bc001d0b80148f48097
     * tab : job
     * content : <div class="markdown-text"><p>杭州大搜车，诚聘 Node.js 服务端开发！</p>
     * <p>加分项：</p>
     * <ul>
     * <li>优秀的推动能力；</li>
     * <li>真正的参与开源项目；</li>
     * <li>厚实的服务端开发经验；</li>
     * <li><strong>不</strong>是“全栈开发”；</li>
     * <li>有其他后台语言的开发和架构经验</li>
     * </ul>
     * <p>下面是详细的招聘说明</p>
     * <h2>关于公司</h2>
     * <p>大搜车位于杭州市余杭区五常大道 175 号，独立 2 栋连体办公楼，办公环境一级棒，一楼有很大的健身区 / 台球室 / 瑜伽房，还有大面积的室内停车位。</p>
     * <p>公司创立于 2013 年，在二手车行业摸打滚爬 3 余载，融资已经 D 轮，投资方碉堡不过还不能透露。公司业务一路从 B2C，到 B2B，到后来融合大小商家的管理系统，质保金融系统，一直走在同行业的前列，网站 App 已经被抄了 N 次，不过并没有卵用，看着一个个追随者在后面你死我活的，我司笑而不语。</p>
     * <h2>关于团队</h2>
     * <p>大搜车前端研发部开始于 2014 年，成立近两年来，沉淀了很多技术方面的经验，公司主技术栈：VueJS，AngularJS，ReactJS，Webpack + 传统选型等，开始我们的选型其实很保守，也制定了很多变态的规范，因为初期很多东西很难把握，规范和简单可以让团队的代码维护性保持健康可控的成长。后来团队同学慢慢成长起来后，前端圈的一些技术也越来越成熟，我们对一些常用技术栈做了深入尝试，并且总结每个解决方案的问题和优势，对其中一些方案标准化，对各自使用的场景也基本有自己的理解，现在团队技术栈比较开，鼓励大家尝试新东西，并且把我代码可维护性。</p>
     * <p>团队同时承接一块重要的服务端业务，使用 Nodejs 开发，团队的 NodeJS 开发均是纯服务端出身的大拿，我觉得这一点对于 Node.js 服务端开发还是很重要的，毕竟 Node.js 只是一个工具。我们的业务非常复杂，所以对于开发同学的挑战也很大，包括业务上的还有系统保障上，都做了很多事情，现在也还在成长中。不过在公司内，大家非常尊重这种异构的文化，每一种语言都有自己的特长，互相融合互相竞争能更好的营造技术氛围。</p>
     * <p>我们有自己的node服务化开发框架，node日志&amp;报警系统，node性能监控系统，内部npm，Node底层SDK化，开发文档接口定义系统，自己的ORM库，公共队列系统，自动化运维体系，执行严格的gitflow&amp;&amp;eslint规范，完善的单测方案。还有更多好玩的需要你的加入。</p>
     * <h2>福利</h2>
     * <p>全员 Retina Macbook Pro，免费高档健康晚餐，每月团队活动基金，每周的组内技术分享，全员持股，每年普发一次期权，然后根据贡献发一次期权，每年涨薪！健身房台球室随便玩！还能免费洗车！</p>
     * <h2>招聘</h2>
     * <p>目前因为 D 轮马上就要到账了，业务急剧增加，同时我们还要做很多应对业务增长的底层优化和周边保障，所以急需前端开发工程师和 Node.js 开发工程师加入我们团队。</p>
     * <h3>具体要求</h3>
     * <h4>前端开发</h4>
     * <ul>
     * <li>熟悉 Vue / Angular / React 至少一个库，有实际开发经验。</li>
     * <li>对自己做过的项目，用过的方案有深入思考，最好简历里有所体现。</li>
     * <li>对技术有热情，乐于接触新事物，做事情态度端正。</li>
     * </ul>
     * <h4>Node.js 服务端</h4>
     * <ul>
     * <li>熟悉 Express / Koa 等常用框架，对 MVC 有一定了解，或者有自己的一套应用开发理念。</li>
     * <li>熟悉数据库操作，熟悉缓存应用。</li>
     * <li>熟悉常见的应用性能优化，监控，分析方法。</li>
     * <li>熟悉常用的 NPM 库。</li>
     * <li>熟悉标准 Git Flow 开发流程。</li>
     * <li>有单元测试 &amp; 集成测试自动化经验。</li>
     * </ul>
     * <blockquote>
     * <p>加分项： 有或者参与 Github 开源项目。 有博客。 是漂亮妹子。</p>
     * </blockquote>
     * <h2>联系方式</h2>
     * <p>简历直接发送至邮箱： <a href="mailto:sunxinyu@souche.com">sunxinyu@souche.com</a> 。如果您符合要求，会第一时间约见。</p>
     * <p>如果还有其他疑问，可以加我微信（微信号：mier963）</p>
     * </div>
     * title : 杭州大搜车Node服务端团队需要您的加入！
     * last_reply_at : 2016-09-14T02:50:09.562Z
     * good : true
     * top : false
     * reply_count : 28
     * visit_count : 3674
     * create_at : 2016-06-12T09:16:07.245Z
     * author : {"loginname":"xinyu198736","avatar_url":"//gravatar.com/avatar/d00d8e3461257418a62b1cb7abeea85a?size=48"}
     */

    private List<DataBean> data;

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public List<DataBean> getData() {
        return data;
    }

    public void setData(List<DataBean> data) {
        this.data = data;
    }

    public static class DataBean {
        private String id;
        private String author_id;
        private String tab;
        private String content;
        private String title;
        private String last_reply_at;
        private boolean good;
        private boolean top;
        private int reply_count;
        private int visit_count;
        private String create_at;
        /**
         * loginname : xinyu198736
         * avatar_url : //gravatar.com/avatar/d00d8e3461257418a62b1cb7abeea85a?size=48
         */

        private AuthorBean author;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getAuthor_id() {
            return author_id;
        }

        public void setAuthor_id(String author_id) {
            this.author_id = author_id;
        }

        public String getTab() {
            return tab;
        }

        public void setTab(String tab) {
            this.tab = tab;
        }

        public String getContent() {
            return content;
        }

        public void setContent(String content) {
            this.content = content;
        }

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getLast_reply_at() {
            return last_reply_at;
        }

        public void setLast_reply_at(String last_reply_at) {
            this.last_reply_at = last_reply_at;
        }

        public boolean isGood() {
            return good;
        }

        public void setGood(boolean good) {
            this.good = good;
        }

        public boolean isTop() {
            return top;
        }

        public void setTop(boolean top) {
            this.top = top;
        }

        public int getReply_count() {
            return reply_count;
        }

        public void setReply_count(int reply_count) {
            this.reply_count = reply_count;
        }

        public int getVisit_count() {
            return visit_count;
        }

        public void setVisit_count(int visit_count) {
            this.visit_count = visit_count;
        }

        public String getCreate_at() {
            return create_at;
        }

        public void setCreate_at(String create_at) {
            this.create_at = create_at;
        }

        public AuthorBean getAuthor() {
            return author;
        }

        public void setAuthor(AuthorBean author) {
            this.author = author;
        }

        public static class AuthorBean {
            private String loginname;
            private String avatar_url;

            public String getLoginname() {
                return loginname;
            }

            public void setLoginname(String loginname) {
                this.loginname = loginname;
            }

            public String getAvatar_url() {
                return avatar_url;
            }

            public void setAvatar_url(String avatar_url) {
                this.avatar_url = avatar_url;
            }
        }
    }
}
